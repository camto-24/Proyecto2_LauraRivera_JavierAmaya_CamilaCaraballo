}
}
# Histograma y Boxplot para variables numéricas
graficos_adicionales_num <- function(varname, df) {
# --- Histograma
histo <- ggplot(df, aes(x=!!sym(varname))) +
geom_histogram(fill=pal[10], color="white", bins=30) +
labs(title=paste0("Histograma: ", varname), x=varname, y="Frecuencia") +
theme_minimal()
ggsave(paste0("Graficos-tablas/hist_num_", varname, ".png"), plot=histo, width=10, height=6, dpi=300)
# --- Boxplot
box <- ggplot(df, aes(x=factor(1), y=!!sym(varname))) +
geom_boxplot(fill=pal[15], outlier.color="red", outlier.size=1.5) +
labs(title=paste0("Boxplot: ", varname), x="", y=varname) +
theme_minimal()
ggsave(paste0("Graficos-tablas/box_num_", varname, ".png"), plot=box, width=6, height=6, dpi=300)
}
# Aplicar solo a variables numéricas
for(cat in names(vars_numericas)){
for(var in vars_numericas[[cat]]){
graficos_adicionales_num(var, df_analisis)
}
}
df_bivariado <- df_analisis %>%
mutate(
# Manejo de NAs en Educación:
nivel_educativo = fct_na_value_to_level(nivel_educativo, level = "Sin Información"),
# Ordenamiento lógico de la variable de exposición para gráficas
consumo_agrupado = fct_relevel(consumo_agrupado,
"No consume",
"Ocasional (< 2/sem)",
"Frecuente (2-6/sem)",
"Diario (Todos los días)"),
# Ajustando la codificación de sexo
sexo = factor(sexo,
levels = c(1, 2),
labels = c("Hombre", "Mujer")),
# Creación de grupos etarios
grupo_edad = case_when(
edad < 30 ~ "Jóvenes (18-29)",
edad >= 30 & edad < 40 ~ "Adultos Jóvenes (30-39)",
edad >= 40 & edad < 50 ~ "Adultez Media (40-49)",
edad >= 50 & edad < 60 ~ "Madurez (50-59)",
edad >= 60 & edad < 70 ~ "Adulto mayor (60-69)",
edad >= 70 ~ "Vejez extrema (70+)"
),
# Ordenamos los niveles para los gráficops
grupo_edad = factor(grupo_edad, levels = c("Jóvenes (18-29)",
"Adultos Jóvenes (30-39)",
"Adultez Media (40-49)",
"Madurez (50-59)",
"Adulto mayor (60-69)",
"Vejez extrema (70+)"))
)
# A) Tabla Global
df_grafico_global <- df_bivariado %>%
group_by(consumo_agrupado) %>%
summarise(
poblacion_total = sum(fex, na.rm = TRUE),
poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
prevalencia = poblacion_enferma / poblacion_total,
preva_100 = (poblacion_enferma / poblacion_total) * 100,
pob_total_mill = round(poblacion_total / 1000000, 2),
.groups = "drop"
)
# B) Tabla Estratificada por Edad
df_grafico_estratificado <- df_bivariado %>%
group_by(grupo_edad, consumo_agrupado) %>%
summarise(
poblacion_total = sum(fex, na.rm = TRUE),
poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
prevalencia = poblacion_enferma / poblacion_total,
preva_100 = (poblacion_enferma / poblacion_total) * 100,
.groups = "drop"
)
# C) Tabla Estratificada por Sexo y Edad (Para Heatmap y Líneas)
df_grafico_sexo <- df_bivariado %>%
group_by(sexo, grupo_edad, consumo_agrupado) %>%
summarise(
poblacion_total = sum(fex, na.rm = TRUE),
poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
prevalencia = poblacion_enferma / poblacion_total,
preva_100 = (poblacion_enferma / poblacion_total) * 100,
.groups = "drop"
) %>%
mutate(grupo_edad_rev = fct_rev(grupo_edad))
# Función auxiliar para formatear y guardar
exportar_html <- function(data, titulo, nombre_archivo) {
data %>%
mutate(across(where(is.numeric), \(x) round(x, 2))) %>%
kbl(caption = titulo, format = "html", align = 'c') %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = F, position = "center") %>%
row_spec(0, bold = T, color = "white", background = "#2c3e50") %>%
save_kable(file = file.path("Graficos-tablas", paste0(nombre_archivo, ".html")))
}
# Generar las 3 tablas clave
exportar_html(df_grafico_global, "Prevalencia Global Ponderada", "Bivariado_prevalencia_global")
exportar_html(df_grafico_estratificado, "Prevalencia por Edad", "Bivariado_prevalencia_edad")
exportar_html(df_grafico_sexo, "Prevalencia por Sexo y Edad", "Bivariado_prevalencia_edad_sexo")
# ==============================================================================
# Visualización bivariada
library(ggplot2)
library(ggthemes)
library(scales)
library(paletteer)
# Definiendo la paleta
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")
# --- GRÁFICO 1: GLOBAL (PARADOJA) ---
p_global <- ggplot(df_grafico_global, aes(x = consumo_agrupado, y = prevalencia)) +
geom_line(group = 1, linetype = "dashed", color = "grey50") +
geom_point(size = 5, color = "#4E79A7") +
geom_text(aes(label = paste0(round(preva_100, 1), "%")),
vjust = -1.5, size = 4, fontface = "bold", color = "#2c3e50") +
scale_y_continuous(labels = percent_format(), limits = c(0, 0.30)) +
labs(
title = "Prevalencia de enf. crónica según intensidad de consumo",
subtitle = "Análisis global: paradoja de causalidad reversa",
x = NULL, y = "Prevalencia (%)",
caption = "Fuente: ECV 2023. Población expandida."
) +
theme_few() +
theme(axis.text.x = element_text(angle = 15, hjust = 1))
# --- GRÁFICO 2: ESTRATIFICADO POR EDAD (CURVA J) ---
p_estratificado <- ggplot(df_grafico_estratificado,
aes(x = consumo_agrupado, y = prevalencia, color = grupo_edad)) +
geom_line(aes(group = grupo_edad), linewidth = 1, alpha = 0.8) +
geom_point(size = 3) +
facet_wrap(~grupo_edad, scales = "free_y") +
scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
scale_color_paletteer_d("ggthemes::Tableau_10") +
labs(
title = "Prevalencia según intensidad de consumo por grupo etario",
subtitle = "Controlando por edad aparecen patrones de riesgo (Curva J)",
x = "Frecuencia de consumo",
y = "Prevalencia (%)",
color = "Grupo de edad"
) +
ggthemes::theme_few() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none",
strip.text = element_text(face = "bold", size = 10)
)
# --- GRÁFICO 3: MAPA DE CALOR SEXO ---
df_heatmap_sexo <- df_grafico_sexo %>% mutate(grupo_edad = fct_rev(grupo_edad))
p_heatmap_sexo <- ggplot(df_heatmap_sexo, aes(x = consumo_agrupado, y = grupo_edad, fill = prevalencia)) +
geom_tile(color = "white", linewidth = 0.5) +
facet_wrap(~sexo) +
geom_text(aes(label = paste0(round(preva_100, 1), "%")),
color = ifelse(df_heatmap_sexo$preva_100 > 25, "white", "#2c3e50"),
size = 3, fontface = "bold") +
scale_fill_gradientn(colors = paleta_teal, labels = percent_format()) +
labs(
title = "Mapa de calor: riesgo de enfermedad crónica por Sexo",
subtitle = "Efecto del sesgo de supervivencia",
x = NULL, y = NULL, fill = "Prevalencia"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
axis.text.y = element_text(size = 10, face = "bold"),
strip.text = element_text(size = 12, face = "bold", color = "#006064"),
panel.grid = element_blank()
)
# --- GRÁFICO 4: TENDENCIAS POR SEXO ---
p_lineas_sexo <- ggplot(df_grafico_sexo,
aes(x = consumo_agrupado, y = prevalencia, color = sexo, group = sexo)) +
geom_line(size = 1.2, alpha = 0.9) +
geom_point(size = 3) +
# Haciendo el faceting por grupo de edad
facet_wrap(~grupo_edad, nrow = 1) +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
# Paleta seleccionada para el proyecto
scale_color_manual(values = c("Hombre" = "#2c3e50", "Mujer" = "#26C6DA")) +
labs(
title = "Tendencias por sexo y grupo etario",
subtitle = "Comparación de prevalencia entre hombres y mujeres",
x = NULL,
y = "Prevalencia (%)",
color = "Sexo"
) +
theme_few() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
legend.position = "bottom",
strip.text = element_text(face = "bold")
)
# Guardar Gráficos
ggsave("Graficos-tablas/bivariado_graph_global.png", p_global, width = 8, height = 6)
ggsave("Graficos-tablas/bivariado_graph_edad.png", p_estratificado, width = 10, height = 6)
ggsave("Graficos-tablas/bivariado_heatmap_graph_edad_sexo.png", p_heatmap_sexo, width = 12, height = 7)
ggsave("Graficos-tablas/bivaariado_lineas_sexo_edad.png", p_lineas_sexo, width = 12, height = 6)
# Mostrar en RMarkdown
print(p_global)
print(p_estratificado)
print(p_heatmap_sexo)
print(p_lineas_sexo)
# --- CHUNK 5: Test de Independencia con Diseño Muestral ---
library(survey)
# Definiendo el diseño muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_bivariado)
# Tabla cruzada ponderada
print("--- Tabla de Contingencia Poblacional (Millones de personas) ---")
svytable(~consumo_agrupado + cronica_binaria, design = diseno_muestral)
# Test de Chi-Cuadrado de Rao-Scott (Corrección para encuestas complejas)
test_survey <- svychisq(~consumo_agrupado + cronica_binaria, design = diseno_muestral)
print("--- Resultado Chi-Cuadrado Ajustado (Rao-Scott) ---")
print(test_survey)
library(survey)
library(broom)
# Configuración de Referencias:
# Referencia: Frecuente (Control) | Jóvenes | Hombres
df_model <- df_bivariado %>%
mutate(
consumo_agrupado = relevel(consumo_agrupado, ref = "Frecuente (2-6/sem)"),
grupo_edad = relevel(grupo_edad, ref = "Jóvenes (18-29)"),
sexo = relevel(sexo, ref = "Hombre")
)
# Diseño Muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_model)
# Ajuste del Modelo (Interacción Triple)
modelo_interaccion <- svyglm(
cronica_num ~ consumo_agrupado * grupo_edad * sexo,
design = diseno_muestral,
family = quasibinomial()
)
# Tabla de Resultados Tidy
tabla_resultados <- tidy(modelo_interaccion, exponentiate = TRUE, conf.int = TRUE) %>%
select(term, estimate, conf.low, conf.high, p.value) %>%
mutate(
across(c(estimate, conf.low, conf.high), \(x) round(x, 2)),
p_valor_formato = ifelse(p.value < 0.001, "< 0.001", as.character(round(p.value, 3)))
) %>%
# Limpieza de nombres de variables
mutate(term = gsub("consumo_agrupado", "Consumo: ", term),
term = gsub("grupo_edad", "Edad: ", term),
term = gsub("sexoMujer", "Mujer", term),
term = gsub(":", " x ", term))
# Preparación de datos para el Forest Plot
# Clasificamos los coeficientes según el mecanismo económico/epidemiológico
df_forest_conceptual <- tabla_resultados %>%
filter(term == "Mujer" | grepl("Consumo", term)) %>%
filter(!grepl("Edad", term)) %>% # Filtramos interacciones de edad para limpieza visual
mutate(
Mecanismo = case_when(
grepl("Diario", term) & !grepl("Mujer", term) ~ "1. Efecto tratamiento (margen intensivo)",
(grepl("No consume", term) | grepl("Ocasional", term)) & !grepl("Mujer", term) ~ "2. Sesgo de endogeneidad (causalidad reversa)",
term == "Mujer" ~ "3. Control de heterogeneidad (sexo)",
TRUE ~ "Otros"
),
term_clean = case_when(
grepl("Diario", term) ~ "Consumo diario (intensificación)",
grepl("Ocasional", term) ~ "Consumo ocasional (reducción)",
grepl("No consume", term) ~ "No consume (abstinencia)",
term == "Mujer" ~ "Ser mujer (vs hombre)",
TRUE ~ term
)
) %>%
filter(Mecanismo != "Otros") %>%
filter(!grepl("Mujer", term) | term == "Mujer")
# B) Generación del Gráfico
p_forest_concept <- ggplot(df_forest_conceptual,
aes(x = estimate, y = reorder(term_clean, estimate), color = Mecanismo)) +
geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.3, size = 0.8) +
geom_point(size = 4) +
geom_text(aes(label = paste0("OR: ", estimate)), vjust = -1.5, size = 3.5, fontface = "bold") +
# Facetas con títulos centrados arriba
facet_wrap(~Mecanismo, ncol = 1, scales = "free_y") +
scale_x_log10() +
scale_color_manual(values = c(
"1. Efecto tratamiento (margen intensivo)" = "#D62728",
"2. Sesgo de endogeneidad (causalidad reversa)" = "#FF7F0E",
"3. Control de heterogeneidad (sexo)" = "#1F77B4"
)) +
labs(
title = "Identificación del efecto del consumo de azúcar",
subtitle = "Odds Ratios usando como referencia el consumo Frecuente",
x = "Odds Ratio", y = NULL,
caption = "Nota: Estimación svyglm ponderada. Panel 1 muestra efecto estructural. Panel 2 muestra selección adversa."
) +
theme_bw() +
theme(
axis.text.y = element_text(face = "bold", size = 11),
strip.text = element_text(face = "bold", size = 11, color = "white", hjust = 0.5), # Centrado
strip.background = element_rect(fill = "#2c3e50"),
legend.position = "none",
panel.grid.minor = element_blank(),
panel.spacing = unit(1, "lines")
)
print(p_forest_concept)
ggsave("Graficos-tablas/bivariado_forest_conceptual_multivariado.png", p_forest_concept, width = 11, height = 8)
# Preparación de llaves y IDs
df_modelo <- df_bivariado %>%
mutate(
# Llaves Únicas
id_hogar   = paste0(directorio, "-", secuencia_p),
id_persona = paste0(directorio, "-", secuencia_p, "-", orden),
# Asegurar formato carácter para cruces
cod_mpio  = as.character(cod_mpio),
cod_depto = as.character(cod_depto)
)
# Dimensión geográfica
dim_geografia <- df_modelo %>%
select(cod_mpio, cod_depto) %>%
distinct() %>%
arrange(cod_depto, cod_mpio)
# Dimensión hogar (Economía y Entorno)
# Aquí va el ingreso_pc porque es dato de hogar
dim_hogar <- df_modelo %>%
select(id_hogar, cod_mpio, ingreso_pc) %>%
group_by(id_hogar) %>%
slice(1) %>%
ungroup()
# Dimensión del consumo de bebidas azucaradas (variable de exposición en el analisis)
dim_consumo <- df_modelo %>%
select(
consume_azucar,          # Si/No (Original)
frecuencia_azucar,       # 1-6 (Original)
freq_num,                # Numérico equivalente a si=1 y no=0
consumo_agrupado,        # Factor ordenado (Tu variable principal)
consumo_agrupado_txt,    # Texto
consumo_detallado        # Factor detallado
) %>%
distinct() %>%
arrange(consumo_detallado) %>%
mutate(id_consumo = row_number())
# Dimensión demográfica
dim_demografia <- df_modelo %>%
select(
id_persona,
sexo,
grupo_edad,
parentesco,
nivel_educativo,
# Incluimos las variables de desenlace en versión texto para filtros
cronica_binaria,   # "Sí"/"No"
cronica_12m        # "1"/"2"
)
# Tabla de hechos
fact_personas <- df_modelo %>%
# Traemos el id_consumo cruzando por TODAS las variables para ser precisos
left_join(dim_consumo,
by = c("consume_azucar", "frecuencia_azucar", "freq_num",
"consumo_agrupado", "consumo_agrupado_txt", "consumo_detallado")) %>%
select(
# Llaves para relacionar (Foreign Keys)
id_persona,      # Relación 1:1 con Dim_Demografia
id_hogar,        # Relación N:1 con Dim_Hogar
id_consumo,      # Relación N:1 con Dim_Consumo
# Variables Numéricas (Metrics)
fex,             # Factor de expansión (CRUCIAL)
edad,            # Edad exacta (para promedios)
cronica_num,     # 0/1 (Para calcular prevalencias)
freq_num         # Por si quieres calcular "Frecuencia promedio de consumo"
)
# Exportando la tabla a excel para que la pueda tomar power BI
lista_tablas_final <- list(
"Hechos_Personas" = fact_personas,
"Dim_Hogar"       = dim_hogar,
"Dim_Demografia"  = dim_demografia,
"Dim_Geografia"   = dim_geografia,
"Dim_Consumo"     = dim_consumo
)
write_xlsx(lista_tablas_final, "Data/Modelo_Datos_Completo.xlsx")
View(dim_geografia)
# Dimensión geográfica
dim_geografia <- df_modelo %>%
select(id_geografia, cod_depto, cod_mpio) %>%
distinct() %>%
group_by(id_geografia) %>%
slice(1) %>%
ungroup()
# Preparación de llaves y IDs
df_modelo <- df_bivariado %>%
mutate(
# Llaves Únicas
id_hogar   = paste0(directorio, "-", secuencia_p),
id_persona = paste0(directorio, "-", secuencia_p, "-", orden),
# Asegurar formato carácter para cruces
cod_mpio  = as.character(cod_mpio),
cod_depto = as.character(cod_depto),
id_geografia = paste0(cod_depto, cod_mpio),
)
# Dimensión geográfica
dim_geografia <- df_modelo %>%
select(id_geografia, cod_depto, cod_mpio) %>%
distinct() %>%
group_by(id_geografia) %>%
slice(1) %>%
ungroup()
# Preparación de llaves y IDs
df_modelo <- df_bivariado %>%
mutate(
# Llaves Únicas
id_hogar   = paste0(directorio, "-", secuencia_p),
id_persona = paste0(directorio, "-", secuencia_p, "-", orden),
# Asegurar formato carácter para cruces
cod_mpio  = as.character(cod_mpio),
cod_depto = as.character(cod_depto),
id_geografia = paste0(cod_depto, cod_mpio),
)
# Dimensión geográfica
dim_geografia <- df_modelo %>%
select(id_geografia, cod_depto, cod_mpio) %>%
distinct() %>%
group_by(id_geografia) %>%
slice(1) %>%
ungroup()
# Dimensión hogar (Economía y Entorno)
# Aquí va el ingreso_pc porque es dato de hogar
dim_hogar <- df_modelo %>%
select(id_hogar, id_geografia, ingreso_pc) %>%
group_by(id_hogar) %>%
slice(1) %>%
ungroup()
# Dimensión del consumo de bebidas azucaradas (variable de exposición en el analisis)
dim_consumo <- df_modelo %>%
select(
consume_azucar,          # Si/No (Original)
frecuencia_azucar,       # 1-6 (Original)
freq_num,                # Numérico equivalente a si=1 y no=0
consumo_agrupado,        # Factor ordenado (Tu variable principal)
consumo_agrupado_txt,    # Texto
consumo_detallado        # Factor detallado
) %>%
distinct() %>%
arrange(consumo_detallado) %>%
mutate(id_consumo = row_number())
# Dimensión demográfica
dim_demografia <- df_modelo %>%
select(
id_persona,
sexo,
grupo_edad,
parentesco,
nivel_educativo,
# Incluimos las variables de desenlace en versión texto para filtros
cronica_binaria,   # "Sí"/"No"
cronica_12m        # "1"/"2"
)
# Tabla de hechos
fact_personas <- df_modelo %>%
# Traemos el id_consumo cruzando por TODAS las variables para ser precisos
left_join(dim_consumo,
by = c("consume_azucar", "frecuencia_azucar", "freq_num",
"consumo_agrupado", "consumo_agrupado_txt", "consumo_detallado")) %>%
select(
# Llaves para relacionar (Foreign Keys)
id_persona,      # Relación 1:1 con Dim_Demografia
id_hogar,        # Relación N:1 con Dim_Hogar
id_consumo,      # Relación N:1 con Dim_Consumo
# Variables Numéricas (Metrics)
fex,             # Factor de expansión
edad,            # Edad exacta (para promedios)
cronica_num,     # 0/1 (Para calcular prevalencias)
freq_num         # Por si quieres calcular "Frecuencia promedio de consumo"
)
# Exportando la tabla a excel para que la pueda tomar power BI
lista_tablas_final <- list(
"Hechos_Personas" = fact_personas,
"Dim_Hogar"       = dim_hogar,
"Dim_Demografia"  = dim_demografia,
"Dim_Geografia"   = dim_geografia,
"Dim_Consumo"     = dim_consumo
)
write_xlsx(lista_tablas_final, "Data/Modelo_Datos_Completo.xlsx")
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")
# Cargando los paquetes usando pacman
pacman::p_load(
# A) Manipulación, limpieza y visualización de datos
tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
here,
haven,
kableExtra,
paletteer,
ggplot2,
ggthemes,
broom,
stringr,
gt,
webshot2,
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr,         # Generación de reportes dinámicos.
writexl
)
#//////// Rutas y datos iniciales de las 4 bases
#getwd()
ruta <- here("data")
# Base 1: Salud
salud <- read_dta(file.path(ruta, "Salud.dta"))
