y = "Densidad",
fill = "Tipo de Medida",
color = "Tipo de Medida",
caption = "Fuente: Elaboración propia. Los pesos (fex) se aplican al cálculo de la densidad ponderada."
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
legend.position = "bottom",
axis.text = element_text(color = "black")
)
print(grafico_densidad_edad)
# Guardar gráfico
ggsave("Graficos-tablas/univariado_edad.png",
grafico_densidad_edad,
width = 8,
height = 6)
# Cálculo NO Ponderado (Muestra real)
tabla_no_pond_cd <- df_analisis %>%
count(consumo_detallado) %>%
mutate(prop_no_pond = n / sum(n)) %>%
rename(freq_no_pond = n)
# Cálculo Ponderado (Estimación poblacional)
tabla_pond_cd <- df_analisis %>%
group_by(consumo_detallado) %>%
summarise(freq_pond = sum(fex, na.rm = TRUE)) %>%
ungroup() %>%
mutate(prop_pond = freq_pond / sum(freq_pond))
# --- Unir tablas
tabla_final_cd <- tabla_no_pond_cd %>%
left_join(tabla_pond_cd, by = "consumo_detallado")
print(head(tabla_final_cd))
# Gráfico
datos_grafico_cd <- tabla_final_cd %>%
select(consumo_detallado, prop_no_pond, prop_pond) %>%
pivot_longer(
cols = c(prop_no_pond, prop_pond),
names_to = "tipo_medida",
values_to = "proporcion"
) %>%
mutate(
tipo_medida = case_when(
tipo_medida == "prop_no_pond" ~ "Muestra (No Ponderado)",
tipo_medida == "prop_pond" ~ "Población (Ponderado)"
)
)
# Paleta TEAL
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")
univariado_consumo_det <- ggplot(datos_grafico_cd,
aes(x = consumo_detallado,
y = proporcion,
fill = tipo_medida)) +
geom_col(position = "dodge", width = 0.7) +
scale_fill_manual(values = c(paleta_teal[3], paleta_teal[5])) +
scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
labs(
title = "Comparación: Muestra vs. Población Estimada",
subtitle = "Distribución de consumo de bebidas azucaradas (detallado)",
x = "Categoría de consumo",
y = "Porcentaje (%)",
fill = "Tipo de Medida",
caption = "Fuente: Elaboración propia"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 14),
legend.position = "bottom",
axis.text = element_text(color = "black", size = 11),
panel.grid = element_blank(),
axis.line = element_line(color = "gray")
) +
geom_text(
aes(label = scales::percent(proporcion, accuracy = 0.1)),
position = position_dodge(width = 0.7),
hjust = -0.1,  # Ajusta la posición horizontal de las etiquetas
size = 3.5
) +
coord_flip()  # Esto voltea el gráfico
print(univariado_consumo_det)
# Guardar gráfico
ggsave("Graficos-tablas/univariado_consumo_detallado.png",
univariado_consumo_det,
width = 8,
height = 6)
# Estadísticos No Ponderados
stats_no_pond <- df_analisis %>%
summarise(
N_obs = n(),
Media = mean(edad, na.rm = TRUE),
DS = sd(edad, na.rm = TRUE),
Q25 = quantile(edad, 0.25, na.rm = TRUE),
Mediana = quantile(edad, 0.50, na.rm = TRUE),
Q75 = quantile(edad, 0.75, na.rm = TRUE),
RIQ = Q75 - Q25,
Min = min(edad, na.rm = TRUE),
Max = max(edad, na.rm = TRUE)
) %>%
mutate(Tipo = "No ponderado")
# Estadísticos Ponderados
stats_pond <- df_analisis %>%
summarise(
N_obs = sum(fex, na.rm = TRUE),
Media = weighted.mean(edad, w = fex, na.rm = TRUE),
DS = sqrt(sum(fex * (edad - weighted.mean(edad, w = fex, na.rm = TRUE))^2, na.rm = TRUE) / sum(fex, na.rm = TRUE)),
Q25 = wtd.quantile(edad, weights = fex, probs = 0.25, na.rm = TRUE),
Mediana = wtd.quantile(edad, weights = fex, probs = 0.5, na.rm = TRUE),
Q75 = wtd.quantile(edad, weights = fex, probs = 0.75, na.rm = TRUE),
RIQ = Q75 - Q25,
Min = min(edad, na.rm = TRUE),
Max = max(edad, na.rm = TRUE)
) %>%
mutate(Tipo = "Ponderado")
# Combinar tablas
tabla_final_edad <- bind_rows(stats_no_pond, stats_pond) %>%
select(Tipo, N_obs, Media, DS, Mediana, RIQ, Min, Max) %>%
mutate(across(c(Media, DS, Mediana, RIQ, Min, Max), ~round(., 2)))
print(tabla_final_edad)
# Gráfico de densidad comparativo
paleta_teal <- c("#0097A7", "#26C6DA")
grafico_densidad_edad <- ggplot() +
geom_density(data = df_analisis,
aes(x = edad, color = "No ponderado", fill = "No ponderado"),
alpha = 0.5, linewidth = 1) +
geom_density(data = df_analisis,
aes(x = edad, weight = fex, color = "Ponderado", fill = "Ponderado"),
alpha = 0.5, linewidth = 1) +
scale_fill_manual(values = c("No ponderado" = paleta_teal[2], "Ponderado" = paleta_teal[1])) +
scale_color_manual(values = c("No ponderado" = paleta_teal[1], "Ponderado" = paleta_teal[1])) +
labs(
title = "Distribución de la Edad: No Ponderada vs Ponderada",
x = "Edad",
y = "Densidad",
fill = "Tipo de Medida",
color = "Tipo de Medida",
caption = "Fuente: Elaboración propia. Los pesos (fex) se aplican al cálculo de la densidad ponderada."
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
legend.position = "bottom",
axis.text = element_text(color = "black")
)
print(grafico_densidad_edad)
# Guardar gráfico
ggsave("Graficos-tablas/univariado_edad.png",
grafico_densidad_edad,
width = 8,
height = 6)
# Estadísticos No Ponderados
stats_no_pond <- df_analisis %>%
summarise(
N_obs = n(),
Media = mean(edad, na.rm = TRUE),
DS = sd(edad, na.rm = TRUE),
Q25 = quantile(edad, 0.25, na.rm = TRUE),
Mediana = quantile(edad, 0.50, na.rm = TRUE),
Q75 = quantile(edad, 0.75, na.rm = TRUE),
RIQ = Q75 - Q25,
Min = min(edad, na.rm = TRUE),
Max = max(edad, na.rm = TRUE)
) %>%
mutate(Tipo = "No ponderado")
# Estadísticos Ponderados
stats_pond <- df_analisis %>%
summarise(
N_obs = sum(fex, na.rm = TRUE),
Media = weighted.mean(edad, w = fex, na.rm = TRUE),
DS = sqrt(sum(fex * (edad - weighted.mean(edad, w = fex, na.rm = TRUE))^2, na.rm = TRUE) / sum(fex, na.rm = TRUE)),
Q25 = wtd.quantile(edad, weights = fex, probs = 0.25, na.rm = TRUE),
Mediana = wtd.quantile(edad, weights = fex, probs = 0.5, na.rm = TRUE),
Q75 = wtd.quantile(edad, weights = fex, probs = 0.75, na.rm = TRUE),
RIQ = Q75 - Q25,
Min = min(edad, na.rm = TRUE),
Max = max(edad, na.rm = TRUE)
) %>%
mutate(Tipo = "Ponderado")
# Combinar tablas
tabla_final_edad <- bind_rows(stats_no_pond, stats_pond) %>%
select(Tipo, N_obs, Media, DS, Mediana, RIQ, Min, Max) %>%
mutate(across(c(Media, DS, Mediana, RIQ, Min, Max), ~round(., 2)))
print(tabla_final_edad)
# Gráfico de densidad comparativo
paleta_teal <- c("#0097A7", "#26C6DA")
grafico_densidad_edad <- ggplot() +
geom_density(data = df_analisis,
aes(x = edad, color = "No ponderado", fill = "No ponderado"),
alpha = 0.5, linewidth = 1) +
geom_density(data = df_analisis,
aes(x = edad, weight = fex, color = "Ponderado", fill = "Ponderado"),
alpha = 0.5, linewidth = 1) +
scale_fill_manual(values = c("No ponderado" = paleta_teal[2], "Ponderado" = paleta_teal[1])) +
scale_color_manual(values = c("No ponderado" = paleta_teal[1], "Ponderado" = paleta_teal[1])) +
labs(
title = "Distribución de la Edad: No Ponderada vs Ponderada",
x = "Edad",
y = "Densidad",
fill = "Tipo de Medida",
color = "Tipo de Medida",
caption = "Fuente: Elaboración propia"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
legend.position = "bottom",
axis.text = element_text(color = "black")
)
print(grafico_densidad_edad)
# Guardar gráfico
ggsave("Graficos-tablas/univariado_edad.png",
grafico_densidad_edad,
width = 8,
height = 6)
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")
# Cargando los paquetes usando pacman
pacman::p_load(
# A) Manipulación, limpieza y visualización de datos
tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
here,
haven,
kableExtra,
paletteer,
ggplot2,
ggthemes,
broom,
stringr,
gt,
webshot2,
Hmisc,
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr,         # Generación de reportes dinámicos.
writexl
)
#//////// Rutas y datos iniciales de las 4 bases
#install.packages("here")
#getwd()
ruta <- here("data")
# Base 1: Salud
salud <- read_dta(file.path(ruta, "Salud.dta"))
# Base 2: Características y composición del hogar
caracteristicas <- read_dta(file.path(ruta, "Características y composición del hogar.dta"))
# Base 3: Educación
educacion <- read_dta(file.path(ruta, "Educación.dta"))
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")
# Cargando los paquetes usando pacman
pacman::p_load(
# A) Manipulación, limpieza y visualización de datos
tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
here,
haven,
kableExtra,
paletteer,
ggplot2,
ggthemes,
broom,
stringr,
gt,
webshot2,
Hmisc,
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr,         # Generación de reportes dinámicos.
writexl
)
#//////// Rutas y datos iniciales de las 4 bases
#install.packages("here")
#getwd()
ruta <- here("data")
# Base 1: Salud
salud <- read_dta(file.path(ruta, "Salud.dta"))
getwd()
#//////// Rutas y datos iniciales de las 4 bases
install.packages("here")
install.packages("here")
getwd()
ruta <- here("data")
ruta_archivo <- "C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2"
salud <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Educación.DTA")
caracteristicas <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Características y composición del hogar.DTA")
educacion <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Educación.DTA)
salud <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Salud.DTA")
salud <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Salud.DTA")
educacion <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Educación.DTA)
educacion <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Educación.DTA)
educacion <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Educación.DTA")
servicios <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Servicios del hogar.DTA")
vivienda <- read_dta("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Data Analysis/Actividades/Proyecto 2/Datos de la vivienda.DTA")
#//////// Mantener solo las variables de interés
# 1. Base de Salud (Nivel Persona)
df_salud <- salud %>%
select(DIRECTORIO, SECUENCIA_P, ORDEN,
P1707,       # Consumo bebidas azucaradas
P1707S1,     # Frecuencia consumo
P1930)       # Diagnóstico enfermedad crónica
# 2. Base de Características del Hogar (Nivel Persona)
df_caracteristicas <- caracteristicas %>%
select(DIRECTORIO, SECUENCIA_P, ORDEN, FEX_C,
P6020,       # Sexo
P6040,       # Edad
P6051)       # Jefe del hogar
# 3. Base de Educación (Nivel Persona)
df_educacion <- educacion %>%
select(DIRECTORIO, SECUENCIA_P, ORDEN,
P8587)       # Variable nivel educativo
# 4. Base de Servicios del Hogar (Nivel Hogar)
df_servicios <- servicios %>%
select(DIRECTORIO,
SECUENCIA_P,
PERCAPITA   # Ingreso per cápita
)
# 5. Base de Datos de la Vivienda (Nivel Vivienda)
df_vivienda <- vivienda %>%
select(DIRECTORIO,
P1_DEPARTAMENTO,
P1_MUNICIPIO)
View(df_salud)
View(salud)
#//////// Se verifican los duplicados
# 1. SALUD
n_dupli_salud <- df_salud %>%
group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>%
filter(n() > 1) %>%
nrow()
print(paste("Duplicados en Salud:", n_dupli_salud))
# 2. CARACTERÍSTICAS
n_dupli_caract <- df_caracteristicas %>%
group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>%
filter(n() > 1) %>%
nrow()
print(paste("Duplicados en Características:", n_dupli_caract))
# 3. EDUCACIÓN
n_dupli_educ <- df_educacion %>%
group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>%
filter(n() > 1) %>%
nrow()
print(paste("Duplicados en Educación:", n_dupli_educ))
# 4. SERVICIOS DEL HOGAR
n_dupli_servicios <- df_servicios %>%
group_by(DIRECTORIO, SECUENCIA_P) %>%
filter(n() > 1) %>%
nrow()
print(paste("Duplicados en Servicios:", n_dupli_servicios))
# Corrección eliminando duplicados
df_servicios <- df_servicios %>%
group_by(DIRECTORIO, SECUENCIA_P) %>%
slice_head(n = 1) %>%
ungroup()
# Verificar de nuevo
n_dupli_servicios_post <- df_servicios %>%
group_by(DIRECTORIO, SECUENCIA_P) %>%
filter(n() > 1) %>%
nrow()
print(paste("Duplicados en Servicios después de corregir:", n_dupli_servicios_post))
# 5. VIVIENDA
n_dupli_vivienda <- df_vivienda %>%
group_by(DIRECTORIO) %>%
filter(n() > 1) %>%
nrow()
print(paste("Duplicados en Vivienda:", n_dupli_vivienda))
#//////// Se unen las 5 bases
df_final_c <- df_salud %>%
# Join 1: Nivel Persona con Persona (uno a uno)
left_join(df_caracteristicas, by = c("DIRECTORIO", "SECUENCIA_P", "ORDEN")) %>%
# Join 2: Nivel Persona con Persona (uno a uno)
left_join(df_educacion,       by = c("DIRECTORIO", "SECUENCIA_P", "ORDEN")) %>%
# Join 3: Nivel Persona con Hogar (muchos a Uno)
left_join(df_servicios,       by = c("DIRECTORIO", "SECUENCIA_P")) %>%
# Join 4: Nivel Persona con Vivienda (muchos a Uno)
left_join(df_vivienda,        by = c("DIRECTORIO"))
# Copia del df original
df_final <- df_final_c
# revisión general y de los missing
skimr::skim(df_final)
#//////// Renombramiento y limpieza final de variables
df_final <- df_final %>%
rename(
# --- Variable Dependiente ---
# P1930: ¿Diagnóstico de enfermedad crónica en últimos 12 meses?
cronica_12m = P1930,
# --- Variable Independiente ---
# P1707: ¿Consume bebidas azucaradas?
consume_azucar = P1707,
# P1707S1: Frecuencia de consumo
frecuencia_azucar = P1707S1,
# --- Variables de Control (Sociodemográficas) ---
# P6020: Sexo
sexo = P6020,
# P6040: Edad
edad = P6040,
# P6051: Parentesco con jefe de hogar
parentesco = P6051,
# P8587: Nivel educativo más alto
nivel_educativo = P8587,
# Geografía
cod_depto = P1_DEPARTAMENTO,
cod_mpio  = P1_MUNICIPIO,
# Economía del hogar
ingreso_pc = PERCAPITA,
# Factor de expansión (Peso muestral)
fex = FEX_C
) %>%
janitor::clean_names()
# Verificación de los nuevos nombres
skimr::skim(df_final)
View(salud)
summary(df_final$edad)
summary(df_final$ingreso_pc)
summary(df_final$fex)
hist(df_final$edad)
hist(log(df_final$ingreso_pc))
hist(log(df_final$fex))
class(df_final$edad)
class(df_final$ingreso_pc)
class(df_final$fex)
# //////// Redefinimos las variables que son categóricas por su naturaleza según la ECV
df_final <- df_final %>%
mutate(
# Se asignan como caracter para poder operar las variables
directorio = as.character(directorio),
secuencia_p = as.character(secuencia_p),
orden = as.character(orden),
cod_mpio          = as.character(cod_mpio),
cod_depto         = as.character(cod_depto),
# se asignan como factores
sexo              = factor(sexo),
parentesco        = factor(parentesco),
nivel_educativo   = factor(nivel_educativo),
cronica_12m       = factor(cronica_12m),
consume_azucar    = factor(consume_azucar),
frecuencia_azucar = factor(frecuencia_azucar)
)
summary(df_final)
# AJUSTE VARIABLES CATEGÓRICAS
df_final <- df_final %>%
mutate(
# VARIABLES DEPENDIENTE E INDEPENDIENTE
# Variable Dependiente: Diagnóstico de enfermedad crónica (P1930)
cronica_12m = factor(cronica_12m,
levels = c(1, 2),
labels = c("Sí", "No")),
# Variable Independiente: Consumo de bebidas azucaradas (P1707)
consume_azucar = factor(consume_azucar,
levels = c(1, 2),
labels = c("Sí", "No")),
# Variable Independiente: Frecuencia de consumo de bebidas azucaradas (P1707S1)
frecuencia_azucar = factor(frecuencia_azucar,
levels = 1:6,
labels = c("Todos los días (≥2 veces)",
"Todos los días (1 vez)",
"4 a 6 veces/semana",
"2 a 3 veces/semana",
"Una vez/semana",
"Menos de 1 vez/semana")),
# VARIABLES DE CONTROL
# sexo ya ajustada
# Parentesco (P6051)
parentesco = factor(parentesco,
levels = 1:14,
labels = c("Jefe/a del hogar", "Pareja/Cónyuge/Compañero/a", "Hijo/a/Hijastro/a",
"Nieto/a", "Padre/Madre/Padrastro/Madrastra", "Suegro/a",
"Hermano/a/Hermanastro/a", "Yerno/Nuera", "Otro/a pariente del/de la jefe/a",
"Empleado/a del servicio doméstico", "Parientes del servicio doméstico",
"Trabajador/a", "Pensionista", "Otro/a no pariente")),
# Nivel educativo más alto alcanzado (P8587)
nivel_educativo = factor(nivel_educativo,
levels = 1:13,
labels = c("Ninguno", "Preescolar", "Básica Primaria",
"Básica Secundaria", "Media",
"Técnico sin título", "Técnico con título",
"Tecnológico sin título", "Tecnológico con título",
"Universitario sin titulo", "Universitario con titulo",
"Postgrado sin titulo", "Postgrado con titulo"))
)
skimr::skim(df_final)
