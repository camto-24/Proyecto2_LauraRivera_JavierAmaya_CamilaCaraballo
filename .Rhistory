# Crear HTML con kable
html_tabla <- lista_tablas[[nombre]] %>%
kable(format = "html",
caption = gsub("_", " ", nombre), # Título legible en la tabla
align = 'c') %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = F,
position = "center") %>%
column_spec(1, bold = T) %>% # Negrita a la primera columna
as.character()
# Guardar
writeLines(html_tabla, ruta_archivo)
}
#//////// Se revisa la base
# 1. Detectar categorías especiales
categorias_especiales <- c(
"No sabe", "No responde", "Ns/Nr",
"ns", "nr", "sin dato", "no aplica",
98, 99, 999, 9999
)
# 2. Función auxiliar para detectar outliers (método IQR)
detectar_outliers <- function(x) {
if (!is.numeric(x)) return(NA_integer_)
q1 <- quantile(x, 0.25, na.rm = TRUE)
q3 <- quantile(x, 0.75, na.rm = TRUE)
iqr <- q3 - q1
sum(x < (q1 - 1.5*iqr) | x > (q3 + 1.5*iqr), na.rm = TRUE)
}
# 3. Tabla resumen completa
tabla_resumen <- df_analisis %>%
summarise(
variable = names(.),
tipo = map_chr(., ~ class(.x)[1]),
n_observaciones = map_int(., length),
n_na = map_int(., ~ sum(is.na(.x))),
categorias_especiales = map_int(., ~ sum(.x %in% categorias_especiales)),
mezcla_ns_nr = map_lgl(., ~ any(.x %in% categorias_especiales) & !all(.x %in% categorias_especiales)),
outliers = map_int(., detectar_outliers)
) %>%
unnest(cols = c(tipo, n_observaciones, n_na, categorias_especiales, mezcla_ns_nr, outliers))
tabla_resumen
# Variables Categóricas
vars_categoricas <- list(
"Habitos" = c("consume_azucar", "frecuencia_azucar"),
"Sociodemograficas" = c("sexo", "parentesco", "nivel_educativo"),
"Salud" = c("cronica_12m", "cronica_binaria")
)
# Variables Numéricas
vars_numericas <- list(
"Sociodemograficas" = c("edad", "ingreso_pc")
)
# Función para Variables Categóricas
analisis_univariado_cat <- function(varname, df) {
# --- Tabla sin ponderar
tabla_simple <- df %>%
filter(!is.na(!!sym(varname))) %>%
count(!!sym(varname)) %>%
mutate(
n_sinpond = as.numeric(n),
porc_sinpond = round(100 * n / sum(n), 1)
) %>%
select(!!sym(varname), n_sinpond, porc_sinpond)
# --- Tabla ponderada
tabla_pond <- df %>%
filter(!is.na(!!sym(varname))) %>%
group_by(!!sym(varname)) %>%
summarise(n_pond = sum(fex, na.rm = TRUE), .groups = "drop") %>%
mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))
# --- Combinar
tabla_comp <- tabla_simple %>%
full_join(tabla_pond, by = varname) %>%
arrange(!!sym(varname))
# --- Guardar tabla HTML
color_header <- pal[25]
tabla_html <- tabla_comp %>%
kable(
"html",
caption = paste0("<b style='color:", color_header, "; font-size:16px;'>Variable Categórica: ", varname, "</b>"),
col.names = c(varname, "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
digits = 1
) %>%
add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"),
position = "center") %>%
row_spec(0, bold = TRUE, color = "white", background = color_header)
save_kable(tabla_html, paste0("Graficos-tablas/tabla_cat_", varname, ".html"))
# --- Gráfico de Barras
tabla_grafico <- tabla_comp %>%
select(!!sym(varname), porc_sinpond, porc_pond) %>%
pivot_longer(cols = c(porc_sinpond, porc_pond),
names_to = "tipo", values_to = "porc") %>%
mutate(tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar"))
grafico <- ggplot(tabla_grafico, aes(x = factor(!!sym(varname)), y = porc, fill = tipo)) +
geom_col(position = "dodge", alpha = 0.9) +
geom_text(aes(label = paste0(porc, "%")),
position = position_dodge(width = 0.9), vjust = -0.4, size = 3.5) +
scale_fill_manual(values = c("Sin ponderar" = pal[10], "Ponderado" = pal[25])) +
labs(title = paste0("Distribución: ", varname), x = varname, y = "Porcentaje", fill = "Tipo") +
theme_minimal()
ggsave(paste0("Graficos-tablas/grafico_cat_", varname, ".png"), plot = grafico, width = 10, height = 6)
}
# Función para Variables Numéricas
analisis_univariado_cont <- function(varname, df) {
# 1. Calcular Estadísticos Descriptivos
stats <- df %>%
filter(!is.na(!!sym(varname))) %>%
summarise(
Media_SP = mean(!!sym(varname)),
Mediana_SP = median(!!sym(varname)),
Min_SP = min(!!sym(varname)),
Max_SP = max(!!sym(varname)),
Media_Pond = weighted.mean(!!sym(varname), w = fex)
) %>%
pivot_longer(cols = everything(), names_to = "Metrica", values_to = "Valor")
# 2. Guardar Tabla de Estadísticos
color_header <- pal[25]
tabla_html <- stats %>%
mutate(Valor = round(Valor, 2)) %>%
kable("html", caption = paste0("<b style='color:", color_header, "; font-size:16px;'>Variable Numérica: ", varname, "</b>")) %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"), position = "center") %>%
row_spec(0, bold = TRUE, color = "white", background = color_header)
save_kable(tabla_html, paste0("Graficos-tablas/tabla_num_", varname, ".html"))
# 3. Gráfico de Densidad (Curva) comparativo
grafico <- ggplot(df, aes(x = !!sym(varname))) +
geom_density(aes(fill = "Sin ponderar"), alpha = 0.4) +
geom_density(aes(weight = fex, fill = "Ponderado"), alpha = 0.4) +
scale_fill_manual(name = "Tipo", values = c("Sin ponderar" = pal[10], "Ponderado" = pal[25])) +
labs(
title = paste0("Distribución (Densidad): ", varname),
subtitle = "Comparación de distribución ponderada vs muestral",
x = varname,
y = "Densidad"
) +
theme_minimal() +
theme(legend.position = "top")
ggsave(paste0("Graficos-tablas/grafico_num_", varname, ".png"), plot = grafico, width = 10, height = 6)
}
# --- Variables categóricas
for(grupo in names(vars_categoricas)){
for(varname in vars_categoricas[[grupo]]){
analisis_univariado_cat(varname, df_analisis)
}
}
# --- Variables numéricas
for(grupo in names(vars_numericas)){
for(varname in vars_numericas[[grupo]]){
analisis_univariado_cont(varname, df_analisis)
}
}
# Histograma y Boxplot para variables numéricas
graficos_adicionales_num <- function(varname, df) {
# --- Histograma
histo <- ggplot(df, aes(x=!!sym(varname))) +
geom_histogram(fill=pal[10], color="white", bins=30) +
labs(title=paste0("Histograma: ", varname), x=varname, y="Frecuencia") +
theme_minimal()
ggsave(paste0("Graficos-tablas/hist_num_", varname, ".png"), plot=histo, width=10, height=6, dpi=300)
# --- Boxplot
box <- ggplot(df, aes(x=factor(1), y=!!sym(varname))) +
geom_boxplot(fill=pal[15], outlier.color="red", outlier.size=1.5) +
labs(title=paste0("Boxplot: ", varname), x="", y=varname) +
theme_minimal()
ggsave(paste0("Graficos-tablas/box_num_", varname, ".png"), plot=box, width=6, height=6, dpi=300)
}
# Aplicar solo a variables numéricas
for(cat in names(vars_numericas)){
for(var in vars_numericas[[cat]]){
graficos_adicionales_num(var, df_analisis)
}
}
df_bivariado <- df_analisis %>%
mutate(
# Manejo de NAs en Educación:
nivel_educativo = fct_na_value_to_level(nivel_educativo, level = "Sin Información"),
# Ordenamiento lógico de la variable de exposición para gráficas
consumo_agrupado = fct_relevel(consumo_agrupado,
"No consume",
"Ocasional (< 2/sem)",
"Frecuente (2-6/sem)",
"Diario (Todos los días)"),
# Ajustando la codificación de sexo
sexo = factor(sexo,
levels = c(1, 2),
labels = c("Hombre", "Mujer")),
# Creación de grupos etarios
grupo_edad = case_when(
edad < 30 ~ "Jóvenes (18-29)",
edad >= 30 & edad < 40 ~ "Adultos Jóvenes (30-39)",
edad >= 40 & edad < 50 ~ "Adultez Media (40-49)",
edad >= 50 & edad < 60 ~ "Madurez (50-59)",
edad >= 60 & edad < 70 ~ "Adulto mayor (60-69)",
edad >= 70 ~ "Vejez extrema (70+)"
),
# Ordenamos los niveles para los gráficops
grupo_edad = factor(grupo_edad, levels = c("Jóvenes (18-29)",
"Adultos Jóvenes (30-39)",
"Adultez Media (40-49)",
"Madurez (50-59)",
"Adulto mayor (60-69)",
"Vejez extrema (70+)"))
)
# A) Tabla Global
df_grafico_global <- df_bivariado %>%
group_by(consumo_agrupado) %>%
summarise(
poblacion_total = sum(fex, na.rm = TRUE),
poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
prevalencia = poblacion_enferma / poblacion_total,
preva_100 = (poblacion_enferma / poblacion_total) * 100,
pob_total_mill = round(poblacion_total / 1000000, 2),
.groups = "drop"
)
# B) Tabla Estratificada por Edad
df_grafico_estratificado <- df_bivariado %>%
group_by(grupo_edad, consumo_agrupado) %>%
summarise(
poblacion_total = sum(fex, na.rm = TRUE),
poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
prevalencia = poblacion_enferma / poblacion_total,
preva_100 = (poblacion_enferma / poblacion_total) * 100,
.groups = "drop"
)
# C) Tabla Estratificada por Sexo y Edad (Para Heatmap y Líneas)
df_grafico_sexo <- df_bivariado %>%
group_by(sexo, grupo_edad, consumo_agrupado) %>%
summarise(
poblacion_total = sum(fex, na.rm = TRUE),
poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
prevalencia = poblacion_enferma / poblacion_total,
preva_100 = (poblacion_enferma / poblacion_total) * 100,
.groups = "drop"
) %>%
mutate(grupo_edad_rev = fct_rev(grupo_edad))
# Función auxiliar para formatear y guardar
exportar_html <- function(data, titulo, nombre_archivo) {
data %>%
mutate(across(where(is.numeric), \(x) round(x, 2))) %>%
kbl(caption = titulo, format = "html", align = 'c') %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = F, position = "center") %>%
row_spec(0, bold = T, color = "white", background = "#2c3e50") %>%
save_kable(file = file.path("Graficos-tablas", paste0(nombre_archivo, ".html")))
}
# Generar las 3 tablas clave
exportar_html(df_grafico_global, "Prevalencia Global Ponderada", "Bivariado_prevalencia_global")
exportar_html(df_grafico_estratificado, "Prevalencia por Edad", "Bivariado_prevalencia_edad")
exportar_html(df_grafico_sexo, "Prevalencia por Sexo y Edad", "Bivariado_prevalencia_edad_sexo")
# ==============================================================================
# Visualización bivariada
library(ggplot2)
library(ggthemes)
library(scales)
library(paletteer)
# Definiendo la paleta
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")
# --- GRÁFICO 1: GLOBAL (PARADOJA) ---
p_global <- ggplot(df_grafico_global, aes(x = consumo_agrupado, y = prevalencia)) +
geom_line(group = 1, linetype = "dashed", color = "grey50") +
geom_point(size = 5, color = "#4E79A7") +
geom_text(aes(label = paste0(round(preva_100, 1), "%")),
vjust = -1.5, size = 4, fontface = "bold", color = "#2c3e50") +
scale_y_continuous(labels = percent_format(), limits = c(0, 0.30)) +
labs(
title = "Prevalencia de enf. crónica según intensidad de consumo",
subtitle = "Análisis global: paradoja de causalidad reversa",
x = NULL, y = "Prevalencia (%)",
caption = "Fuente: ECV 2023. Población expandida."
) +
theme_few() +
theme(axis.text.x = element_text(angle = 15, hjust = 1))
# --- GRÁFICO 2: ESTRATIFICADO POR EDAD (CURVA J) ---
p_estratificado <- ggplot(df_grafico_estratificado,
aes(x = consumo_agrupado, y = prevalencia, color = grupo_edad)) +
geom_line(aes(group = grupo_edad), linewidth = 1, alpha = 0.8) +
geom_point(size = 3) +
facet_wrap(~grupo_edad, scales = "free_y") +
scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
scale_color_paletteer_d("ggthemes::Tableau_10") +
labs(
title = "Prevalencia según intensidad de consumo por grupo etario",
subtitle = "Controlando por edad aparecen patrones de riesgo (Curva J)",
x = "Frecuencia de consumo",
y = "Prevalencia (%)",
color = "Grupo de edad"
) +
ggthemes::theme_few() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none",
strip.text = element_text(face = "bold", size = 10)
)
# --- GRÁFICO 3: MAPA DE CALOR SEXO ---
df_heatmap_sexo <- df_grafico_sexo %>% mutate(grupo_edad = fct_rev(grupo_edad))
p_heatmap_sexo <- ggplot(df_heatmap_sexo, aes(x = consumo_agrupado, y = grupo_edad, fill = prevalencia)) +
geom_tile(color = "white", linewidth = 0.5) +
facet_wrap(~sexo) +
geom_text(aes(label = paste0(round(preva_100, 1), "%")),
color = ifelse(df_heatmap_sexo$preva_100 > 25, "white", "#2c3e50"),
size = 3, fontface = "bold") +
scale_fill_gradientn(colors = paleta_teal, labels = percent_format()) +
labs(
title = "Mapa de calor: riesgo de enfermedad crónica por Sexo",
subtitle = "Efecto del sesgo de supervivencia",
x = NULL, y = NULL, fill = "Prevalencia"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
axis.text.y = element_text(size = 10, face = "bold"),
strip.text = element_text(size = 12, face = "bold", color = "#006064"),
panel.grid = element_blank()
)
# --- GRÁFICO 4: TENDENCIAS POR SEXO ---
p_lineas_sexo <- ggplot(df_grafico_sexo,
aes(x = consumo_agrupado, y = prevalencia, color = sexo, group = sexo)) +
geom_line(size = 1.2, alpha = 0.9) +
geom_point(size = 3) +
# Haciendo el faceting por grupo de edad
facet_wrap(~grupo_edad, nrow = 1) +
scale_y_continuous(labels = percent_format(accuracy = 1)) +
# Paleta seleccionada para el proyecto
scale_color_manual(values = c("Hombre" = "#2c3e50", "Mujer" = "#26C6DA")) +
labs(
title = "Tendencias por sexo y grupo etario",
subtitle = "Comparación de prevalencia entre hombres y mujeres",
x = NULL,
y = "Prevalencia (%)",
color = "Sexo"
) +
theme_few() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
legend.position = "bottom",
strip.text = element_text(face = "bold")
)
# Guardar Gráficos
ggsave("Graficos-tablas/bivariado_graph_global.png", p_global, width = 8, height = 6)
ggsave("Graficos-tablas/bivariado_graph_edad.png", p_estratificado, width = 10, height = 6)
ggsave("Graficos-tablas/bivariado_heatmap_graph_edad_sexo.png", p_heatmap_sexo, width = 12, height = 7)
ggsave("Graficos-tablas/bivaariado_lineas_sexo_edad.png", p_lineas_sexo, width = 12, height = 6)
# Mostrar en RMarkdown
print(p_global)
print(p_estratificado)
print(p_heatmap_sexo)
print(p_lineas_sexo)
# --- CHUNK 5: Test de Independencia con Diseño Muestral ---
library(survey)
# Definiendo el diseño muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_bivariado)
# Tabla cruzada ponderada
print("--- Tabla de Contingencia Poblacional (Millones de personas) ---")
svytable(~consumo_agrupado + cronica_binaria, design = diseno_muestral)
# Test de Chi-Cuadrado de Rao-Scott (Corrección para encuestas complejas)
test_survey <- svychisq(~consumo_agrupado + cronica_binaria, design = diseno_muestral)
print("--- Resultado Chi-Cuadrado Ajustado (Rao-Scott) ---")
print(test_survey)
library(survey)
library(broom)
# Configuración de Referencias:
# Referencia: Frecuente (Control) | Jóvenes | Hombres
df_model <- df_bivariado %>%
mutate(
consumo_agrupado = relevel(consumo_agrupado, ref = "Frecuente (2-6/sem)"),
grupo_edad = relevel(grupo_edad, ref = "Jóvenes (18-29)"),
sexo = relevel(sexo, ref = "Hombre")
)
# Diseño Muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_model)
# Ajuste del Modelo (Interacción Triple)
modelo_interaccion <- svyglm(
cronica_num ~ consumo_agrupado * grupo_edad * sexo,
design = diseno_muestral,
family = quasibinomial()
)
# Tabla de Resultados Tidy
tabla_resultados <- tidy(modelo_interaccion, exponentiate = TRUE, conf.int = TRUE) %>%
select(term, estimate, conf.low, conf.high, p.value) %>%
mutate(
across(c(estimate, conf.low, conf.high), \(x) round(x, 2)),
p_valor_formato = ifelse(p.value < 0.001, "< 0.001", as.character(round(p.value, 3)))
) %>%
# Limpieza de nombres de variables
mutate(term = gsub("consumo_agrupado", "Consumo: ", term),
term = gsub("grupo_edad", "Edad: ", term),
term = gsub("sexoMujer", "Mujer", term),
term = gsub(":", " x ", term))
# Preparación de datos para el Forest Plot
# Clasificamos los coeficientes según el mecanismo económico/epidemiológico
df_forest_conceptual <- tabla_resultados %>%
filter(term == "Mujer" | grepl("Consumo", term)) %>%
filter(!grepl("Edad", term)) %>% # Filtramos interacciones de edad para limpieza visual
mutate(
Mecanismo = case_when(
grepl("Diario", term) & !grepl("Mujer", term) ~ "1. Efecto tratamiento (margen intensivo)",
(grepl("No consume", term) | grepl("Ocasional", term)) & !grepl("Mujer", term) ~ "2. Sesgo de endogeneidad (causalidad reversa)",
term == "Mujer" ~ "3. Control de heterogeneidad (sexo)",
TRUE ~ "Otros"
),
term_clean = case_when(
grepl("Diario", term) ~ "Consumo diario (intensificación)",
grepl("Ocasional", term) ~ "Consumo ocasional (reducción)",
grepl("No consume", term) ~ "No consume (abstinencia)",
term == "Mujer" ~ "Ser mujer (vs hombre)",
TRUE ~ term
)
) %>%
filter(Mecanismo != "Otros") %>%
filter(!grepl("Mujer", term) | term == "Mujer")
# B) Generación del Gráfico
p_forest_concept <- ggplot(df_forest_conceptual,
aes(x = estimate, y = reorder(term_clean, estimate), color = Mecanismo)) +
geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.3, size = 0.8) +
geom_point(size = 4) +
geom_text(aes(label = paste0("OR: ", estimate)), vjust = -1.5, size = 3.5, fontface = "bold") +
# Facetas con títulos centrados arriba
facet_wrap(~Mecanismo, ncol = 1, scales = "free_y") +
scale_x_log10() +
scale_color_manual(values = c(
"1. Efecto tratamiento (margen intensivo)" = "#D62728",
"2. Sesgo de endogeneidad (causalidad reversa)" = "#FF7F0E",
"3. Control de heterogeneidad (sexo)" = "#1F77B4"
)) +
labs(
title = "Identificación del efecto del consumo de azúcar",
subtitle = "Odds Ratios usando como referencia el consumo Frecuente",
x = "Odds Ratio", y = NULL,
caption = "Nota: Estimación svyglm ponderada. Panel 1 muestra efecto estructural. Panel 2 muestra selección adversa."
) +
theme_bw() +
theme(
axis.text.y = element_text(face = "bold", size = 11),
strip.text = element_text(face = "bold", size = 11, color = "white", hjust = 0.5), # Centrado
strip.background = element_rect(fill = "#2c3e50"),
legend.position = "none",
panel.grid.minor = element_blank(),
panel.spacing = unit(1, "lines")
)
print(p_forest_concept)
ggsave("Graficos-tablas/bivariado_forest_conceptual_multivariado.png", p_forest_concept, width = 11, height = 8)
View(df_final)
#//////// Se revisa la base
# 1. Detectar categorías especiales
categorias_especiales <- c(
"No sabe", "No responde", "Ns/Nr",
"ns", "nr", "sin dato", "no aplica",
98, 99, 999, 9999
)
# 2. Función auxiliar para detectar outliers (método IQR)
detectar_outliers <- function(x) {
if (!is.numeric(x)) return(NA_integer_)
q1 <- quantile(x, 0.25, na.rm = TRUE)
q3 <- quantile(x, 0.75, na.rm = TRUE)
iqr <- q3 - q1
sum(x < (q1 - 1.5*iqr) | x > (q3 + 1.5*iqr), na.rm = TRUE)
}
# 3. Tabla resumen completa
tabla_resumen <- df_analisis %>%
summarise(
variable = names(.),
tipo = map_chr(., ~ class(.x)[1]),
n_observaciones = map_int(., length),
n_na = map_int(., ~ sum(is.na(.x))),
categorias_especiales = map_int(., ~ sum(.x %in% categorias_especiales)),
mezcla_ns_nr = map_lgl(., ~ any(.x %in% categorias_especiales) & !all(.x %in% categorias_especiales)),
outliers = map_int(., detectar_outliers)
) %>%
unnest(cols = c(tipo, n_observaciones, n_na, categorias_especiales, mezcla_ns_nr, outliers))
tabla_resumen
#//////// Se revisa la base
# 1. Detectar categorías especiales
categorias_especiales <- c(
"No sabe", "No responde", "Ns/Nr",
"ns", "nr", "sin dato", "no aplica",
98, 99, 999, 9999
)
# 2. Función auxiliar para detectar outliers (método IQR)
detectar_outliers <- function(x) {
if (!is.numeric(x)) return(NA_integer_)
q1 <- quantile(x, 0.25, na.rm = TRUE)
q3 <- quantile(x, 0.75, na.rm = TRUE)
iqr <- q3 - q1
sum(x < (q1 - 1.5*iqr) | x > (q3 + 1.5*iqr), na.rm = TRUE)
}
# 3. Tabla resumen completa
tabla_resumen <- df_analisis %>%
summarise(
variable = names(.),
tipo = map_chr(., ~ class(.x)[1]),
n_observaciones = map_int(., length),
n_na = map_int(., ~ sum(is.na(.x))),
categorias_especiales = map_int(., ~ sum(.x %in% categorias_especiales)),
mezcla_ns_nr = map_lgl(., ~ any(.x %in% categorias_especiales) & !all(.x %in% categorias_especiales)),
outliers = map_int(., detectar_outliers)
) %>%
unnest(cols = c(tipo, n_observaciones, n_na, categorias_especiales, mezcla_ns_nr, outliers))
tabla_resumen
#//////// Se revisa la base
df_analisis %>%
summarise(across(where(is.numeric), list(mean = mean, sd = sd, min = min, max = max), na.rm = TRUE))
#//////// Se revisa la base
df_analisis %>%
summarise(across(
everything(),
~ tibble(
tipo_variable = class(.),
observaciones = sum(!is.na(.))
),
.names = "{.col}"
)) %>%
pivot_longer(everything(), names_to = "variable") %>%
unnest(cols = value)
