---
title: "Proyecto 2 - Visualización y construcción de historias con datos "
subtitle: "Facultad de Economía, Universidad de los Andes"
author: "Camila Caraballo, Laura Rivera y Javier Amaya Nieto"
date: "2025-11-15"
output: html_document
---

# Setup del ambiente

```{r, include=FALSE}
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")

# Cargando los paquetes usando pacman
pacman::p_load(
  
  # A) Manipulación, limpieza y visualización de datos
  tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
  forcats,      # Herramientas para trabajar con variables categóricas (factores).
  tibble,       # Implementación moderna de data.frames.
  janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
  lubridate,    # Manejo avanzado de fechas y horas.
  skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
  stringi,      # Manipulación robusta de texto (strings).
  scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
  openxlsx,     # Guardar excel
  writexl,      # Guardar excel
  here,
  haven,
  kableExtra,
  paletteer,
  ggplot2,
  ggthemes,
  broom,
  stringr,
  gt,
  webshot2,

  # B) Modelado y análisis estadístico/econométrico
  fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
  plm,          # Modelos econométricos para datos de panel.
  AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
  lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
  sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
  survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).

  # C) Importación, exportación y generación de reportes
  haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
  readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
  stargazer,    # Creación de tablas de regresión con formato de publicación.
  knitr,         # Generación de reportes dinámicos.
  writexl
)
```

# Parte 1: Pregunta de interés

o **Pregunta de interés**: ¿Existe una asociación positiva entre el consumo de bebidas azucaradas y la probabilidad de presentar un diagnóstico de enfermedad crónica en los últimos 12 meses?

o **Definición de la población**: Son los individuos residentes de los diferentes municipios y departamentos de Colombia a los que fueron encuestados en la base de salud del Departamento Administrativo Nacional de Estadística (DANE) en el año 2023.

o **Unidad de observación**: Cada observación de la base de salud corresponde a los individuos

o **Variable dependiente**:

**Base 1: Salud**

-   Variable: Diagnóstico de enfermedad crónica (P1930)

    Pregunta: “En los últimos 12 meses, ¿a usted le han diagnosticado alguna enfermedad crónica?”

    Categorías: 1 = Sí / 2 = No

    Tipo: Variable discreta numérica

o **Variable independiente**:

-   Variable: Consumo de bebidas azucaradas (P1707)

    Pregunta: “¿Consume bebidas azucaradas?”

    Categorías: 1 = Sí / 2 = No

    Tipo: Variable discreta numérica

-   Variable: Frecuencia de consumo de bebidas azucaradas (P1707S1)

    Pregunta: “Con que frecuencia consume las bebidas azucaradas:

    Categorías: 1 Todos los días de la semana (dos o más veces al día) 2 Todos los días de la semana (una vez al día) 3 Cuatro a seis veces a la semana 4 Dos o tres veces a la semana 5 Una vez a la semana 6 Menos de una vez por semana

    Tipo: Variable discreta numérica

o **Dimensiones de análisis de interés**: Las variables control que requiere utilizar en el proyecto son:

**Base 2: Características y Composición del Hogar**

-   Variable: Sexo (P6020)

    Pregunta: “¿Cuál es el sexo de la persona?”

    Categorías: 1= Hombre / 2= Mujer

    Tipo: Variable discreta numérica

    Justificación: El riesgo de desarrollar enfermedades crónicas y los patrones de consumo de bebidas azucaradas suelen diferir entre hombres y mujeres. Incluir esta variable permite controlar por diferencias biológicas y de comportamiento alimentario, efectos heterogéneos.

-   Variable: Edad (P6040)

    Pregunta: “¿Cuántos años cumplidos tiene?”

    Tipo: Variable discreta numérica

    Justificación: La edad es el principal factor de riesgo para la aparición de enfermedades crónicas. Además, los hábitos alimenticios tienden a variar a lo largo del ciclo de vida. Por su importancia epidemiológica, debe ser controlada en el análisis.

-   Variable: Parentesto (P6051)

    Pregunta:“¿Cuál es el parentesco de la persona con el jefe/a de hogar?”

    Categorías: 1. Jefe/a del hogar 2. Pareja, esposo/a, cónyuge, compañero/a 3. Hijo/a, hijastro/a 4. Nieto/a 5. Padre, madre, padrastro, madrastra 6. Suegro o suegra 7. Hermano/a, hemanastro/a 8. Yerno, nuera 9. Otro/a pariente del/de la jefe/a 10. Empleado/a del servicio doméstico 11. Parientes del servicio doméstico 12. Trabajador/a 13. Pensionista 14. Otro(a) no pariente

    Tipo: Variable discreta numérica

    Justificación: Permite caracterizar la estructura del hogar y, si se realizan análisis agregados por hogar, identificar roles que influyen en las decisiones alimentarias o responsabilidades en la compra y preparación de alimentos.

**Base 3: Educación**

-   Variable: Nivel educativo más alto alcanzado (P8587)

    Pregunta:“¿Cuál es el nivel educativo más alto que ha alcanzado?”

    Categorías: 1Ninguno 2 Preescolar 3 Básica Primaria (1º - 5º) 4 Básica secundaria (6º--9º) 5 Media (10º -13º) 6 Técnico sin título 7 Técnico con título 8 Tecnológico sin título 9 Tecnológico con título 10 Universitario sin titulo 11 Universitario con titulo 12 Postgrado sin titulo 13 Postgrado con titulo

    Tipo: Variable discreta numérica

    Justificación: El nivel educativo influye en el conocimiento sobre nutrición, el entendimiento de riesgos asociados al consumo de azúcar y la capacidad para adoptar comportamientos saludables.

**Base 4: Servicios del Hogar**

-   Variable: ingreso per capita del hogar (PERCAPITA)

    Descripción:Monto total de ingresos del hogar dividido entre el número de integrantes.

    Tipo: Variable discreta numérica

    Justificación:Refleja la capacidad adquisitiva individual. Determina el tipo y cantidad de alimentos consumidos, incluidos productos ultraprocesados como bebidas azucaradas.

o **Ámbito: Geografía/periodo de referencia o Latente**: ¿Existe? Proxy propuesta (si aplica)

o **Relevancia**: La pregunta de interés de este trabajo es relevante porque permite identificar si el consumo de bebidas azucaradas está asociado con una mayor prevalencia de enfermedades crónicas, lo cual tiene implicaciones directas para la toma de decisiones en salud pública. Comprender esta relación es útil para tomar decisiones de políticas públicas enfocadas a mejorar la externalidad negativa en el consumo de estos productos por medio de impuestos, capacitaciones de salud, regulaciones a los productos con altos porcentajes de azúcar, entre otros.

Además, al contar con información territorial por departamento y municipio, es posible focalizar acciones en las zonas donde se observe mayor riesgo, optimizando recursos y fortaleciendo la planeación sanitaria. Finalmente, esta evidencia contribuye al diseño de estrategias efectivas que busquen reducir la carga de enfermedades crónicas en la población y mejorar su bienestar.

# Parte 2: EDA y modelamiento de datos

• USAR PALETA DE COLORES BLUE-TEAL DEL PAQUETE PALETEER:

-   <https://r-charts.com/es/paletas-colores/>

-   <https://coolors.co/palettes/trending>

-   <https://color.adobe.com/es/>

• USAR EL TEMA ggthemr(“fresh”) del paquete library(ggthemr) disponible para consulta en la pagina: <https://r-charts.com/es/ggplot2/temas/>

### 2.1) Preparación y comprensión inicial de los datos

```{r}
#//////// Rutas y datos iniciales de las 4 bases
#getwd()
ruta <- here("data")

# Base 1: Salud
salud <- read_dta(file.path(ruta, "Salud.dta"))

# Base 2: Características y composición del hogar
caracteristicas <- read_dta(file.path(ruta, "Características y composición del hogar.dta"))

# Base 3: Educación
educacion <- read_dta(file.path(ruta, "Educación.dta"))

# Base 4: Servicios del hogar
servicios <- read_dta(file.path(ruta, "Servicios del hogar.dta"))

# Base 5: Datos de la vivienda
vivienda <- read_dta(file.path(ruta, "Datos de la vivienda.dta"))

# Revisión de las bases
#str(salud)        # tipo de variables
```

```{r}
#//////// Mantener solo las variables de interés 

# 1. Base de Salud (Nivel Persona)
df_salud <- salud %>%
  select(DIRECTORIO, SECUENCIA_P, ORDEN,
         P1707,       # Consumo bebidas azucaradas
         P1707S1,     # Frecuencia consumo
         P1930)       # Diagnóstico enfermedad crónica

# 2. Base de Características del Hogar (Nivel Persona)
df_caracteristicas <- caracteristicas %>%
  select(DIRECTORIO, SECUENCIA_P, ORDEN, FEX_C,
         P6020,       # Sexo
         P6040,       # Edad
         P6051)       # Jefe del hogar

# 3. Base de Educación (Nivel Persona)
df_educacion <- educacion %>%
  select(DIRECTORIO, SECUENCIA_P, ORDEN,
         P8587)       # Variable nivel educativo

# 4. Base de Servicios del Hogar (Nivel Hogar)
df_servicios <- servicios %>%
  select(DIRECTORIO,
         SECUENCIA_P,
         PERCAPITA   # Ingreso per cápita - REVISAR EN EQUIPO
         )       

# 5. Base de Datos de la Vivienda (Nivel Vivienda)
df_vivienda <- vivienda %>%
  select(DIRECTORIO,
         P1_DEPARTAMENTO,
         P1_MUNICIPIO)

```

```{r}
#//////// Se verifican los duplicados

# 1. SALUD
n_dupli_salud <- df_salud %>% 
  group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Salud:", n_dupli_salud))

# 2. CARACTERÍSTICAS
n_dupli_caract <- df_caracteristicas %>% 
  group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Características:", n_dupli_caract))

# 3. EDUCACIÓN
n_dupli_educ <- df_educacion %>% 
  group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Educación:", n_dupli_educ))

# 4. SERVICIOS DEL HOGAR
n_dupli_servicios <- df_servicios %>%
  group_by(DIRECTORIO, SECUENCIA_P) %>%
  filter(n() > 1) %>%
  nrow()
print(paste("Duplicados en Servicios:", n_dupli_servicios))

# Corrección eliminando duplicados
df_servicios <- df_servicios %>%
  group_by(DIRECTORIO, SECUENCIA_P) %>%
  slice_head(n = 1) %>%
  ungroup()

# Verificar de nuevo
n_dupli_servicios_post <- df_servicios %>%
  group_by(DIRECTORIO, SECUENCIA_P) %>%
  filter(n() > 1) %>%
  nrow()

print(paste("Duplicados en Servicios después de corregir:", n_dupli_servicios_post))

# 5. VIVIENDA
n_dupli_vivienda <- df_vivienda %>% 
  group_by(DIRECTORIO) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Vivienda:", n_dupli_vivienda))

```

```{r}
#//////// Se unen las 5 bases
df_final_c <- df_salud %>%
  # Join 1: Nivel Persona con Persona (Match perfecto)
  left_join(df_caracteristicas, by = c("DIRECTORIO", "SECUENCIA_P", "ORDEN")) %>%
  
  # Join 2: Nivel Persona con Persona (Match perfecto)
  left_join(df_educacion,       by = c("DIRECTORIO", "SECUENCIA_P", "ORDEN")) %>%
  
  # Join 3: Nivel Persona con Hogar (Muchos a Uno)
  left_join(df_servicios,       by = c("DIRECTORIO", "SECUENCIA_P")) %>%
  
  # Join 4: Nivel Persona con Vivienda (Muchos a Uno)
  left_join(df_vivienda,        by = c("DIRECTORIO"))

# Copia del df original
df_final <- df_final_c 

# revisión general y de los mising
skimr::skim(df_final)

```

La base fue cargada correctamente y contiene 240.212 observaciones y 14 variables, tal como se observa en el resumen general generado por skim(). La estructura también se verificó: el conjunto tiene 12 variables numéricas y 2 variables de tipo carácter. Ahora se realizará un cambio a los nombres de las variables:

```{r}
#//////// Renombramiento y limpieza final de variables
df_final <- df_final %>%
  rename(
    # --- Variable Dependiente ---
    # P1930: ¿Diagnóstico de enfermedad crónica en últimos 12 meses?
    cronica_12m = P1930,
    
    # --- Variable Independiente ---
    # P1707: ¿Consume bebidas azucaradas?
    consume_azucar = P1707,
    # P1707S1: Frecuencia de consumo
    frecuencia_azucar = P1707S1,
    
    # --- Variables de Control (Sociodemográficas) ---
    # P6020: Sexo
    sexo = P6020,
    # P6040: Edad
    edad = P6040,
    # P6051: Parentesco con jefe de hogar
    parentesco = P6051,
    # P8587: Nivel educativo más alto
    nivel_educativo = P8587,
    # Geografía
    cod_depto = P1_DEPARTAMENTO,
    cod_mpio  = P1_MUNICIPIO,
    # Economía del hogar
    ingreso_pc = PERCAPITA,
    # Factor de expansión (Peso muestral)
    fex = FEX_C
  ) %>%
  janitor::clean_names()

# Verificación de los nuevos nombres
skimr::skim(df_final)
```

```{r}

#//////// Se revisa la base 

# 1. Detectar categorías especiales

categorias_especiales <- c(
  "No sabe", "No responde", "Ns/Nr",
  "ns", "nr", "sin dato", "no aplica",
  98, 99, 999, 9999
)

# 2. Función auxiliar para detectar outliers (método IQR)
detectar_outliers <- function(x) {
  if (!is.numeric(x)) return(NA_integer_)
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  q3 <- quantile(x, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  sum(x < (q1 - 1.5*iqr) | x > (q3 + 1.5*iqr), na.rm = TRUE)
}

# 3. Tabla resumen completa
tabla_resumen <- df_final %>%
  summarise(
    variable = names(.),
    tipo = map_chr(., ~ class(.x)[1]),
    n_observaciones = map_int(., length),
    n_na = map_int(., ~ sum(is.na(.x))),
    categorias_especiales = map_int(., ~ sum(.x %in% categorias_especiales)),
    mezcla_ns_nr = map_lgl(., ~ any(.x %in% categorias_especiales) & !all(.x %in% categorias_especiales)),
    outliers = map_int(., detectar_outliers)
  ) %>%
  unnest(cols = c(tipo, n_observaciones, n_na, categorias_especiales, mezcla_ns_nr, outliers))

tabla_resumen

# Ver las categorías especiales y estan ok a lo que es la variable
sort(unique(df_final$edad))
sort(unique(df_final$cod_depto))

```

```{r}
# //////// Cambiar el tipo a las variables 
df_final <- df_final %>%
  mutate(
    directorio = as.character(directorio),
    secuencia_p = as.character(secuencia_p),
    orden = as.character(orden),
    sexo              = factor(sexo),
    consume_azucar    = factor(consume_azucar),
    frecuencia_azucar = factor(frecuencia_azucar),
    cronica_12m       = factor(cronica_12m),
    parentesco        = factor(parentesco),
    nivel_educativo   = factor(nivel_educativo),
    cod_mpio          = factor(cod_mpio)
  )
summary(df_final)
```

Revisión de outliers: Se identificaron valores atípicos en las variables Fex e ingreso_pc. La variable Fex se mantiene sin modificaciones, ya que es la variable de expansión. En cuanto a ingreso_pc, se revisaron los valores extremos, pero no se realizaron correcciones, dado que el valor máximo corresponde a 250 millones y se considera válido

```{r}
# Se revisan cuantiles de las dos variables que tienen outliers
quantile(df_final$fex, probs = c(0.95,0.99,0.999), na.rm = TRUE)
quantile(df_final$ingreso_pc, probs = c(0.95,0.99,0.999), na.rm = TRUE)

# Se revisan estadísticas de las dos variables que tienen outliers
summary(df_final$fex)
summary(df_final$ingreso_pc)

# Se grafica el outliers de ingreso

# Paleta azul–teal
pal <- paletteer::paletteer_c("ggthemes::Blue-Teal", 30)

# Calcular límites de outliers
Q1 <- quantile(df_final$ingreso_pc, 0.25, na.rm = TRUE)
Q3 <- quantile(df_final$ingreso_pc, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
limite_superior <- Q3 + 1.5 * IQR

# Histograma 
hist_plot <- ggplot() +
  # Valores normales
  geom_histogram(
    data = filter(df_final, ingreso_pc <= limite_superior),
    aes(x = ingreso_pc),
    fill = pal[15], color = "white", bins = 50
  ) +
  # Valores extremos
  geom_histogram(
    data = filter(df_final, ingreso_pc > limite_superior),
    aes(x = ingreso_pc),
    fill = "red", color = "white", bins = 50
  ) +
  scale_x_log10(labels = scales::comma) +
  labs(
    title = "Distribución del Ingreso per Cápita",
    x = "Ingreso per cápita (log10)",
    y = "Frecuencia"
  ) +
  theme_minimal(base_size = 14) +
  theme(panel.grid = element_blank())

# Mostrar gráfico
print(hist_plot)

# Guardar el gráfico
ggsave("Graficos-tablas/histograma_ingreso_pc.png", plot = hist_plot, width = 8, height = 6, dpi = 300)

```

Revisión de NAs: Se revisaron los NA en nivel_educativo, que corresponden principalmente a menores de 5 años, y se mantuvieron sin cambios junto con los de consume_azucar y frecuencia_azucar. Los NA en ingreso_pc se imputaron con la mediana por municipio

```{r}
#//////// Revisando los NA de educación que deben ser los menores de 5 años
# 1. Crear subconjunto solo con NAs en nivel educativo
df_educacion_na <- df_final %>%
  filter(is.na(nivel_educativo))

# 2. Verificación rápida: ¿Quiénes son estos individuos?
summary(df_educacion_na$edad)

#//////// Ahora revisamos la distribución según las diferentes edades

# 3. Distribución de frecuencias de edad en estos nulos
table(df_educacion_na$edad)

skimr::skim(df_educacion_na)

#//////// Se mantienen los NA de las variables de consume_azucar, frecuencia_azucar, nivel_educativo pero se imputa la de ingreso
df_final <- df_final %>%
  group_by(cod_mpio) %>%
  mutate(ingreso_pc = ifelse(is.na(ingreso_pc),
                             median(ingreso_pc, na.rm = TRUE),
                             ingreso_pc)) %>%
  ungroup()


```

Excluyendo de los análisis los menores de edad:

Durante la exploración de los datos, se evidenció una ausencia sistemática de información en la variable de **nivel educativo** para la población menor de 18 años (hallazgo estructural derivado del diseño de la encuesta). Dado que el objetivo del presente análisis es caracterizar la relación entre el consumo de bebidas azucaradas y las enfermedades crónicas, se decidió restringir la muestra exclusivamente a **adultos (**$\ge$ 18 años). Esta delimitación obedece a dos criterios prácticos:

1.  **Coherencia en la caracterización socioeconómica:** Para realizar cruces descriptivos válidos según el nivel educativo, es necesario contar con información completa en esta variable. Incluir menores de edad generaría una categoría de "Sin Información" artificialmente alta que dificultaría la interpretación de los perfiles poblacionales.

2.  **Focalización epidemiológica:** Las enfermedades crónicas analizadas son eventos propios de la etapa adulta. Incluir población pediátrica (donde la prevalencia del evento es cercana a cero) distorsionaría las frecuencias relativas y las tasas de prevalencia generales, opacando los patrones de salud que se buscan identificar en la población de riesgo.

```{r}
# Creación del dataset analítico definitivo
df_analisis <- df_final %>%
  # 1. CRITERIO DE INCLUSIÓN: Población Adulta
  filter(edad >= 18) 

# Verificación final:
skim(df_analisis$nivel_educativo)
```

Ahora teniendo la base de datos limpia, podemos consolidar una variable adicional de intencidad de consumo de bebidas azucaradas:

```{r}
# 1. PREPARACIÓN DE DATOS
# Realizamos todas las transformaciones y etiquetado en un solo bloque para evitar conflictos.

df_analisis <- df_analisis %>%
  mutate(
    # --- A. Variable de Desenlace (Y) ---
    # Primero numérico 0/1
    cronica_num = if_else(cronica_12m == 1, 1, 0),
    # Inmediatamente lo convertimos a Factor con etiquetas finales
    cronica_binaria = factor(cronica_num, 
                             levels = c(0, 1), 
                             labels = c("No", "Sí")),
    
    # --- B. Variables de exposición (X) ---
    freq_num = case_when(
      consume_azucar == 2 ~ 0,
      TRUE ~ as.numeric(frecuencia_azucar)
    ),
    
    # Agrupada (Texto temporal)
    consumo_agrupado_txt = case_when(
      freq_num == 0 ~ "No consume",
      freq_num %in% c(5, 6) ~ "Ocasional (< 2/sem)",
      freq_num %in% c(3, 4) ~ "Frecuente (2-6/sem)",
      freq_num %in% c(1, 2) ~ "Diario (Todos los días)"
    ),
    
    # Convertimos Agrupada a Factor Ordenado
    consumo_agrupado = factor(consumo_agrupado_txt, 
                              levels = c("No consume", 
                                         "Ocasional (< 2/sem)", 
                                         "Frecuente (2-6/sem)", 
                                         "Diario (Todos los días)")),
    
    # Variable Detallada (Factor Ordenado directo)
    consumo_detallado = factor(freq_num,
                               levels = c(0, 6, 5, 4, 3, 2, 1),
                               labels = c("No consume",
                                          "< 1 vez/sem",
                                          "1 vez/sem",
                                          "2-3 veces/sem",
                                          "4-6 veces/sem",
                                          "Diario (1)",
                                          "Diario (2+)"))
  )

# 2. CONFIGURACIÓN DE EXPORTACIÓN

# Función 
tabla_frec <- function(datos, var) {
  datos %>%
    count({{var}}, .drop = FALSE) %>% 
    mutate(
      n = as.integer(n), # Asegurar que n es entero
      porcentaje = round(n / sum(n) * 100, 1)
    ) %>%
    rename(Categoria = 1, Frecuencia = n, `%` = porcentaje)
}

# 3. GENERACIÓN Y GUARDADO DE TABLAS
lista_tablas <- list(
  "Variable_Agrupada" = df_analisis %>% tabla_frec(consumo_agrupado),
  "Variable_Detallada" = df_analisis %>% tabla_frec(consumo_detallado),
  "Variable_Desenlace_Cronica" = df_analisis %>% tabla_frec(cronica_binaria)
)

for (nombre in names(lista_tablas)) {
  
  # Definir ruta
  ruta_archivo <- file.path("Graficos-tablas", paste0(nombre, ".html"))
  
  # Crear HTML con kable
  html_tabla <- lista_tablas[[nombre]] %>%
    kable(format = "html", 
          caption = gsub("_", " ", nombre), # Título legible en la tabla
          align = 'c') %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                  full_width = F, 
                  position = "center") %>%
    column_spec(1, bold = T) %>% # Negrita a la primera columna
    as.character()
  
  # Guardar
  writeLines(html_tabla, ruta_archivo)
}
```

### 2.2) Análisis univariado sistemático

De la base df_final se obtiene la base df_analisis, filtrada para adultos mayores de 18 años. Esta base contiene 172.538 observaciones con variables de distintos tipos: numéricas, factores y caracteres. Incluye identificadores como directorio, secuencia_p y orden, sin valores faltantes ni categorías especiales.

En cuanto a hábitos de consumo, la variable consume_azucar no presenta NA, mientras que frecuencia_azucar tiene 63.494 valores faltantes correspondientes a aquellas personas que respondieron de forma negativa en la pregunta de consumo de azucar. Las variables de salud, que constituyen la variable dependiente del análisis, como cronica_12m y cronica_binaria, no presentan NA, aunque cronica_num registra 27.297 outliers. Entre las variables sociodemográficas, que se utilizarán como controles, sexo y parentesco no tienen NA; edad contiene 56 categorías especiales y 25 outliers; nivel_educativo presenta 9.781 NA; ingreso_pc tiene 14.907 outliers, y cod_depto cuenta con 3.905 categorías especiales.

Revisión de outliers y valores faltantes: Se identificaron outliers en Fex e ingreso_pc. Fex se mantuvo sin cambios por ser la variable de expansión, mientras que los valores extremos de ingreso_pc tampoco se corrigieron, ya que el valor máximo (250 millones) se considera válido. Respecto a los valores faltantes, los NA en nivel_educativo corresponden principalmente a menores de 5 años y se mantuvieron. Los NA en ingreso_pc se imputaron utilizando la mediana por municipio.

```{r}
#//////// Se revisa la base 

# 1. Detectar categorías especiales

categorias_especiales <- c(
  "No sabe", "No responde", "Ns/Nr",
  "ns", "nr", "sin dato", "no aplica",
  98, 99, 999, 9999
)

# 2. Función auxiliar para detectar outliers (método IQR)
detectar_outliers <- function(x) {
  if (!is.numeric(x)) return(NA_integer_)
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  q3 <- quantile(x, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  sum(x < (q1 - 1.5*iqr) | x > (q3 + 1.5*iqr), na.rm = TRUE)
}

# 3. Tabla resumen completa
tabla_resumen <- df_analisis %>%
  summarise(
    variable = names(.),
    tipo = map_chr(., ~ class(.x)[1]),
    n_observaciones = map_int(., length),
    n_na = map_int(., ~ sum(is.na(.x))),
    categorias_especiales = map_int(., ~ sum(.x %in% categorias_especiales)),
    mezcla_ns_nr = map_lgl(., ~ any(.x %in% categorias_especiales) & !all(.x %in% categorias_especiales)),
    outliers = map_int(., detectar_outliers)
  ) %>%
  unnest(cols = c(tipo, n_observaciones, n_na, categorias_especiales, mezcla_ns_nr, outliers))

tabla_resumen
```

```{r}
# Variables Categóricas 
vars_categoricas <- list(
  "Habitos" = c("consume_azucar", "frecuencia_azucar"),
  "Sociodemograficas" = c("sexo", "parentesco", "nivel_educativo"),
  "Salud" = c("cronica_12m", "cronica_binaria")
)

# Variables Numéricas 
vars_numericas <- list(
  "Sociodemograficas" = c("edad", "ingreso_pc")
)

# Función para Variables Categóricas
analisis_univariado_cat <- function(varname, df) {
  
  # --- Tabla sin ponderar
  tabla_simple <- df %>%
    filter(!is.na(!!sym(varname))) %>% 
    count(!!sym(varname)) %>%
    mutate(
      n_sinpond = as.numeric(n),
      porc_sinpond = round(100 * n / sum(n), 1)
    ) %>%
    select(!!sym(varname), n_sinpond, porc_sinpond)
  
  # --- Tabla ponderada
  tabla_pond <- df %>%
    filter(!is.na(!!sym(varname))) %>%
    group_by(!!sym(varname)) %>%
    summarise(n_pond = sum(fex, na.rm = TRUE), .groups = "drop") %>%
    mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))
  
  # --- Combinar
  tabla_comp <- tabla_simple %>%
    full_join(tabla_pond, by = varname) %>%
    arrange(!!sym(varname))
  
  # --- Guardar tabla HTML
  color_header <- pal[25] 
  
  tabla_html <- tabla_comp %>%
    kable(
      "html",
      caption = paste0("<b style='color:", color_header, "; font-size:16px;'>Variable Categórica: ", varname, "</b>"),
      col.names = c(varname, "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
      digits = 1
    ) %>%
    add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
    kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"),
                  position = "center") %>%
    row_spec(0, bold = TRUE, color = "white", background = color_header)
  
  save_kable(tabla_html, paste0("Graficos-tablas/tabla_cat_", varname, ".html"))
  
  # --- Gráfico de Barras
  tabla_grafico <- tabla_comp %>%
    select(!!sym(varname), porc_sinpond, porc_pond) %>%
    pivot_longer(cols = c(porc_sinpond, porc_pond),
                 names_to = "tipo", values_to = "porc") %>%
    mutate(tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar"))
  
  grafico <- ggplot(tabla_grafico, aes(x = factor(!!sym(varname)), y = porc, fill = tipo)) +
    geom_col(position = "dodge", alpha = 0.9) +
    geom_text(aes(label = paste0(porc, "%")),
              position = position_dodge(width = 0.9), vjust = -0.4, size = 3.5) +
    scale_fill_manual(values = c("Sin ponderar" = pal[10], "Ponderado" = pal[25])) +
    labs(title = paste0("Distribución: ", varname), x = varname, y = "Porcentaje", fill = "Tipo") +
    theme_minimal()
  
  ggsave(paste0("Graficos-tablas/grafico_cat_", varname, ".png"), plot = grafico, width = 10, height = 6)
}

# Función para Variables Numéricas
analisis_univariado_cont <- function(varname, df) {
  
  # 1. Calcular Estadísticos Descriptivos
  stats <- df %>%
    filter(!is.na(!!sym(varname))) %>%
    summarise(
      Media_SP = mean(!!sym(varname)),
      Mediana_SP = median(!!sym(varname)),
      Min_SP = min(!!sym(varname)),
      Max_SP = max(!!sym(varname)),
      Media_Pond = weighted.mean(!!sym(varname), w = fex)
    ) %>%
    pivot_longer(cols = everything(), names_to = "Metrica", values_to = "Valor")
  
  # 2. Guardar Tabla de Estadísticos
  color_header <- pal[25]
  
  tabla_html <- stats %>%
    mutate(Valor = round(Valor, 2)) %>%
    kable("html", caption = paste0("<b style='color:", color_header, "; font-size:16px;'>Variable Numérica: ", varname, "</b>")) %>%
    kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"), position = "center") %>%
    row_spec(0, bold = TRUE, color = "white", background = color_header)
  
  save_kable(tabla_html, paste0("Graficos-tablas/tabla_num_", varname, ".html"))
  
  # 3. Gráfico de Densidad (Curva) comparativo
  grafico <- ggplot(df, aes(x = !!sym(varname))) +
    geom_density(aes(fill = "Sin ponderar"), alpha = 0.4) +
    geom_density(aes(weight = fex, fill = "Ponderado"), alpha = 0.4) +
    scale_fill_manual(name = "Tipo", values = c("Sin ponderar" = pal[10], "Ponderado" = pal[25])) +
    labs(
      title = paste0("Distribución (Densidad): ", varname),
      subtitle = "Comparación de distribución ponderada vs muestral",
      x = varname,
      y = "Densidad"
    ) +
    theme_minimal() +
    theme(legend.position = "top")
  
  ggsave(paste0("Graficos-tablas/grafico_num_", varname, ".png"), plot = grafico, width = 10, height = 6)
}

# --- Variables categóricas
for(grupo in names(vars_categoricas)){
  for(varname in vars_categoricas[[grupo]]){
    analisis_univariado_cat(varname, df_analisis)
  }
}

# --- Variables numéricas
for(grupo in names(vars_numericas)){
  for(varname in vars_numericas[[grupo]]){
    analisis_univariado_cont(varname, df_analisis)
  }
}
```

```{r}

# Histograma y Boxplot para variables numéricas
graficos_adicionales_num <- function(varname, df) {

  # --- Histograma
  histo <- ggplot(df, aes(x=!!sym(varname))) +
    geom_histogram(fill=pal[10], color="white", bins=30) +
    labs(title=paste0("Histograma: ", varname), x=varname, y="Frecuencia") +
    theme_minimal()
  
  ggsave(paste0("Graficos-tablas/hist_num_", varname, ".png"), plot=histo, width=10, height=6, dpi=300)
  
  # --- Boxplot
  box <- ggplot(df, aes(x=factor(1), y=!!sym(varname))) +
    geom_boxplot(fill=pal[15], outlier.color="red", outlier.size=1.5) +
    labs(title=paste0("Boxplot: ", varname), x="", y=varname) +
    theme_minimal()
  
  ggsave(paste0("Graficos-tablas/box_num_", varname, ".png"), plot=box, width=6, height=6, dpi=300)
}

# Aplicar solo a variables numéricas
for(cat in names(vars_numericas)){
  for(var in vars_numericas[[cat]]){
    graficos_adicionales_num(var, df_analisis)
  }
}

```

### 2.3) Análisis bivariado guiado por la pregunta

Una vez comprendidas las variables, realice comparaciones que respondan directamente a la pregunta de indagación. El objetivo es producir evidencia gráfica relevante para sustentar una respuesta. Puede tomar como referencia las sugerencias de visualización del enunciado de la Actividad 2, según corresponda. Incluya los gráficos que considere pertinentes y que ilustren la relaciones entre variables de la pregunta de indagación en el informe. Acompáñelos de un análisis interpretativo.

#### Preparación de variables - bivariado

Ajustando el dataset df_bivariado, corrigiendo los NAs de educación, ordenando los factores de consumo (para que el gráfico tenga sentido de menor a mayor) y creando una variable de edad categórica.

```{r}
df_bivariado <- df_analisis %>%
  mutate(
    # Manejo de NAs en Educación: 
    nivel_educativo = fct_na_value_to_level(nivel_educativo, level = "Sin Información"),
    
    # Ordenamiento lógico de la variable de exposición para gráficas
    consumo_agrupado = fct_relevel(consumo_agrupado, 
                                   "No consume", 
                                   "Ocasional (< 2/sem)", 
                                   "Frecuente (2-6/sem)", 
                                   "Diario (Todos los días)"),
    # Ajustando la codificación de sexo
    sexo = factor(sexo, 
                  levels = c(1, 2), 
                  labels = c("Hombre", "Mujer")),
    
    # Creación de grupos etarios
    grupo_edad = case_when(
      edad < 30 ~ "Jóvenes (18-29)",
      edad >= 30 & edad < 40 ~ "Adultos Jóvenes (30-39)",
      edad >= 40 & edad < 50 ~ "Adultez Media (40-49)",
      edad >= 50 & edad < 60 ~ "Madurez (50-59)",
      edad >= 60 & edad < 70 ~ "Adulto mayor (60-69)",
      edad >= 70 ~ "Vejez extrema (70+)"
    ),
    # Ordenamos los niveles para los gráficops
    grupo_edad = factor(grupo_edad, levels = c("Jóvenes (18-29)", 
                                               "Adultos Jóvenes (30-39)", 
                                               "Adultez Media (40-49)", 
                                               "Madurez (50-59)", 
                                               "Adulto mayor (60-69)", 
                                               "Vejez extrema (70+)"))
  )

```

#### Tablas de prevalencias

Generando las tablas resumen numéricas que alimentarán los gráficos.

```{r}
# A) Tabla Global
df_grafico_global <- df_bivariado %>%
  group_by(consumo_agrupado) %>%
  summarise(
    poblacion_total = sum(fex, na.rm = TRUE),
    poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
    prevalencia = poblacion_enferma / poblacion_total,
    preva_100 = (poblacion_enferma / poblacion_total) * 100,
    pob_total_mill = round(poblacion_total / 1000000, 2),
    .groups = "drop"
  )

# B) Tabla Estratificada por Edad
df_grafico_estratificado <- df_bivariado %>%
  group_by(grupo_edad, consumo_agrupado) %>%
  summarise(
    poblacion_total = sum(fex, na.rm = TRUE),
    poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
    prevalencia = poblacion_enferma / poblacion_total,
    preva_100 = (poblacion_enferma / poblacion_total) * 100,
    .groups = "drop"
  )

# C) Tabla Estratificada por Sexo y Edad (Para Heatmap y Líneas)
df_grafico_sexo <- df_bivariado %>%
  group_by(sexo, grupo_edad, consumo_agrupado) %>%
  summarise(
    poblacion_total = sum(fex, na.rm = TRUE),
    poblacion_enferma = sum(fex[cronica_binaria == "Sí"], na.rm = TRUE),
    prevalencia = poblacion_enferma / poblacion_total,
    preva_100 = (poblacion_enferma / poblacion_total) * 100,
    .groups = "drop"
  ) %>%
  mutate(grupo_edad_rev = fct_rev(grupo_edad)) 

```

Ahora exportamos las tablas al formato seleccionado: 

```{r}
# Función auxiliar para formatear y guardar
exportar_html <- function(data, titulo, nombre_archivo) {
  data %>%
    mutate(across(where(is.numeric), \(x) round(x, 2))) %>% 
    kbl(caption = titulo, format = "html", align = 'c') %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                  full_width = F, position = "center") %>%
    row_spec(0, bold = T, color = "white", background = "#2c3e50") %>% 
    save_kable(file = file.path("Graficos-tablas", paste0(nombre_archivo, ".html")))
}

# Generar las 3 tablas clave
exportar_html(df_grafico_global, "Prevalencia Global Ponderada", "Bivariado_prevalencia_global")
exportar_html(df_grafico_estratificado, "Prevalencia por Edad", "Bivariado_prevalencia_edad")
exportar_html(df_grafico_sexo, "Prevalencia por Sexo y Edad", "Bivariado_prevalencia_edad_sexo")
```

#### Visualizaciones del bivariado

```{r}
# ==============================================================================
# Visualización bivariada 

library(ggplot2)
library(ggthemes)
library(scales)
library(paletteer)

# Definiendo la paleta
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")

# --- GRÁFICO 1: GLOBAL (PARADOJA) ---
p_global <- ggplot(df_grafico_global, aes(x = consumo_agrupado, y = prevalencia)) +
  geom_line(group = 1, linetype = "dashed", color = "grey50") +
  geom_point(size = 5, color = "#4E79A7") + 
  geom_text(aes(label = paste0(round(preva_100, 1), "%")), 
            vjust = -1.5, size = 4, fontface = "bold", color = "#2c3e50") +
  scale_y_continuous(labels = percent_format(), limits = c(0, 0.30)) + 
  labs(
    title = "Prevalencia de enf. crónica según intensidad de consumo",
    subtitle = "Análisis global: paradoja de causalidad reversa",
    x = NULL, y = "Prevalencia (%)",
    caption = "Fuente: ECV 2023. Población expandida."
  ) +
  theme_few() + 
  theme(axis.text.x = element_text(angle = 15, hjust = 1))

# --- GRÁFICO 2: ESTRATIFICADO POR EDAD (CURVA J) ---
p_estratificado <- ggplot(df_grafico_estratificado,
                          aes(x = consumo_agrupado, y = prevalencia, color = grupo_edad)) +
  geom_line(aes(group = grupo_edad), linewidth = 1, alpha = 0.8) + 
  geom_point(size = 3) + 
  facet_wrap(~grupo_edad, scales = "free_y") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
  scale_color_paletteer_d("ggthemes::Tableau_10") +
  labs(
    title = "Prevalencia según intensidad de consumo por grupo etario",
    subtitle = "Controlando por edad aparecen patrones de riesgo (Curva J)",
    x = "Frecuencia de consumo", 
    y = "Prevalencia (%)", 
    color = "Grupo de edad"
  ) +
  ggthemes::theme_few() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), 
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 10) 
  )

# --- GRÁFICO 3: MAPA DE CALOR SEXO ---
df_heatmap_sexo <- df_grafico_sexo %>% mutate(grupo_edad = fct_rev(grupo_edad))

p_heatmap_sexo <- ggplot(df_heatmap_sexo, aes(x = consumo_agrupado, y = grupo_edad, fill = prevalencia)) +
  geom_tile(color = "white", linewidth = 0.5) +
  facet_wrap(~sexo) + 
  geom_text(aes(label = paste0(round(preva_100, 1), "%")), 
            color = ifelse(df_heatmap_sexo$preva_100 > 25, "white", "#2c3e50"), 
            size = 3, fontface = "bold") +
  scale_fill_gradientn(colors = paleta_teal, labels = percent_format()) +
  labs(
    title = "Mapa de calor: riesgo de enfermedad crónica por Sexo",
    subtitle = "Efecto del sesgo de supervivencia",
    x = NULL, y = NULL, fill = "Prevalencia"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10, face = "bold"),
    strip.text = element_text(size = 12, face = "bold", color = "#006064"),
    panel.grid = element_blank()
  )

# --- GRÁFICO 4: TENDENCIAS POR SEXO ---
p_lineas_sexo <- ggplot(df_grafico_sexo, 
                        aes(x = consumo_agrupado, y = prevalencia, color = sexo, group = sexo)) +
  geom_line(size = 1.2, alpha = 0.9) +
  geom_point(size = 3) +
  
  # Haciendo el faceting por grupo de edad
  facet_wrap(~grupo_edad, nrow = 1) + 
  
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  
  # Paleta seleccionada para el proyecto
  scale_color_manual(values = c("Hombre" = "#2c3e50", "Mujer" = "#26C6DA")) +
  
  labs(
    title = "Tendencias por sexo y grupo etario",
    subtitle = "Comparación de prevalencia entre hombres y mujeres",
    x = NULL,
    y = "Prevalencia (%)",
    color = "Sexo"
  ) +
  theme_few() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    legend.position = "bottom",
    strip.text = element_text(face = "bold")
  )

# Guardar Gráficos
ggsave("Graficos-tablas/bivariado_graph_global.png", p_global, width = 8, height = 6)
ggsave("Graficos-tablas/bivariado_graph_edad.png", p_estratificado, width = 10, height = 6)
ggsave("Graficos-tablas/bivariado_heatmap_graph_edad_sexo.png", p_heatmap_sexo, width = 12, height = 7)
ggsave("Graficos-tablas/bivaariado_lineas_sexo_edad.png", p_lineas_sexo, width = 12, height = 6)

# Mostrar en RMarkdown
print(p_global)
print(p_estratificado)
print(p_heatmap_sexo)
print(p_lineas_sexo)
```

Análisis global (paradoja de la causalidad reversa): al examinar la relación cruda entre el consumo de bebidas azucaradas y la enfermedad crónica a nivel nacional, se observa una asociación negativa aparente: la prevalencia de enfermedad es drásticamente mayor en el grupo que "No consume" (24.0%) comparado con quienes consumen "Diariamente" (8.6%). Desde una perspectiva epidemiológica y económica, este hallazgo no sugiere un efecto protector del azúcar, sino que evidencia un fuerte sesgo de selección por causalidad inversa (fenómeno sick-quitter). Es altamente probable que el diagnóstico de patologías como diabetes o hipertensión actúe como el determinante exógeno que fuerza a los individuos a modificar su dieta, concentrando así a la población con peor salud en la categoría de "No consumidores" y distorsionando la estimación del riesgo real.

Estratificación por grupo etario (heterogeneidad del efecto):  Al controlar por decenios de edad, se despeja parcialmente esta distorsión. Si bien el efecto sick-quitter persiste transversalmente (los "No consumidores" siempre son los más enfermos en todos los grupos etarios), el comportamiento dentro de la población consumidora revela patrones divergentes. En los grupos económicamente activos (18 a 59 años), emerge una tendencia no lineal en forma de "J": tras excluir a los abstemios, se observa un gradiente positivo donde la prevalencia repunta al transitar de un consumo "Frecuente" a uno "Diario", sugiriendo una asociación dosis-respuesta oculta en el análisis global. Por el contrario, en la vejez (60+ años), la tendencia se torna linealmente negativa, comportamiento atribuible a la restricción médica estricta y a un marcado sesgo de supervivencia, donde los individuos más vulnerables fallecen prematuramente, disminuyendo artificialmente la prevalencia observada en los consumidores longevos.

Dinámica de género y sesgo de supervivencia diferencial: El análisis de las trayectorias vitales añade una capa de complejidad mediante la brecha de género. Aunque en etapas tempranas (18-29 años) las curvas de prevalencia se solapan, con la edad se produce una separación progresiva donde las mujeres reportan tasas sistemáticamente más altas, atribuible a una mayor frecuencia de diagnóstico y uso de servicios de salud frente al sub-registro masculino. Críticamente, al llegar a la tercera edad, se evidencia una atrición diferencial: mientras las mujeres mantienen el patrón de riesgo en "J" hasta la vejez extrema, los hombres pierden dicha señal a partir de los 60 años. Esto sugiere que los hombres con alto consumo y predisposición a enfermar sufren una mortalidad prematura selectiva, dejando en la muestra de ancianos a un subgrupo de "sobrevivientes resilientes" que sesgan la asociación hacia la nulidad, fenómeno menos acentuado en mujeres debido a su mayor esperanza de vida con morbilidad.

Conclusión del análisis descriptivo: en síntesis, la evidencia descriptiva bivariada sugiere que sí existe una asociación positiva estructural entre la intensidad del consumo y la enfermedad crónica, pero esta relación es condicional a la edad y al sexo. De esta manera, el análisis bivariado puede ser insuficiente debido a la contaminación por causalidad reversa y sesgos de selección y supervivencia. Por consiguiente, es importasnte usar modelos multivariados que aíslen el riesgo biológico real, controlando por la confusión demográfica y ajustando la categoría de referencia para mitigar el sesgo de endogeneidad introducido por el cambio de comportamiento post-diagnóstico.


#### Prueba estadística bivariada

Usamos el paquete survey para poder montar la prueba de hipótesis usando el factor de expansión de la ECV.

```{r}
# --- CHUNK 5: Test de Independencia con Diseño Muestral ---
library(survey)

# Definiendo el diseño muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_bivariado)

# Tabla cruzada ponderada 
print("--- Tabla de Contingencia Poblacional (Millones de personas) ---")
svytable(~consumo_agrupado + cronica_binaria, design = diseno_muestral)

# Test de Chi-Cuadrado de Rao-Scott (Corrección para encuestas complejas)
test_survey <- svychisq(~consumo_agrupado + cronica_binaria, design = diseno_muestral)

print("--- Resultado Chi-Cuadrado Ajustado (Rao-Scott) ---")
print(test_survey)
```

#### Multivariado

```{r}
library(survey)
library(broom)

# Configuración de Referencias:
# Referencia: Frecuente (Control) | Jóvenes | Hombres
df_model <- df_bivariado %>%
  mutate(
    consumo_agrupado = relevel(consumo_agrupado, ref = "Frecuente (2-6/sem)"),
    grupo_edad = relevel(grupo_edad, ref = "Jóvenes (18-29)"),
    sexo = relevel(sexo, ref = "Hombre")
  )

# Diseño Muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_model)

# Ajuste del Modelo (Interacción Triple)
modelo_interaccion <- svyglm(
  cronica_num ~ consumo_agrupado * grupo_edad * sexo, 
  design = diseno_muestral,
  family = quasibinomial()
)

# Tabla de Resultados Tidy
tabla_resultados <- tidy(modelo_interaccion, exponentiate = TRUE, conf.int = TRUE) %>%
  select(term, estimate, conf.low, conf.high, p.value) %>%
  mutate(
    across(c(estimate, conf.low, conf.high), \(x) round(x, 2)),
    p_valor_formato = ifelse(p.value < 0.001, "< 0.001", as.character(round(p.value, 3)))
  ) %>%
  # Limpieza de nombres de variables
  mutate(term = gsub("consumo_agrupado", "Consumo: ", term),
         term = gsub("grupo_edad", "Edad: ", term),
         term = gsub("sexoMujer", "Mujer", term),
         term = gsub(":", " x ", term))
```

Al establecer el 'Consumo Frecuente' como categoría basal —un grupo teóricamente expuesto pero sin el comportamiento extremo de restricción médica—, el modelo multivariado desveló dos mecanismos opuestos que operan simultáneamente en la población. Por un lado, se aisló el Efecto Biológico: la intensificación del hábito hacia un consumo 'Diario' incrementa significativamente la probabilidad de enfermedad crónica (OR = 1.61), confirmando la hipótesis de riesgo por exceso de exposición. Por otro lado, se dimensionó la magnitud de la Causalidad Inversa (Efecto Sick-Quitter): paradójicamente, la reducción del consumo a niveles 'Ocasionales' (OR = 2.25) o la abstinencia total (OR = 3.44) se asocian con los mayores niveles de riesgo. Este gradiente inverso no indica que dejar el azúcar enferme, sino que la enfermedad fuerza a los pacientes a migrar hacia categorías de bajo consumo, concentrando artificialmente la patología en los grupos de menor exposición aparente. El modelo confirma así que la relación no es lineal, sino en forma de 'J', donde tanto el exceso (por causa) como la carencia (por consecuencia) marcan los puntos altos de prevalencia.

#### Forest plot de la regresión

```{r}
# Preparación de datos para el Forest Plot
# Clasificamos los coeficientes según el mecanismo económico/epidemiológico
df_forest_conceptual <- tabla_resultados %>%
  filter(term == "Mujer" | grepl("Consumo", term)) %>%
  filter(!grepl("Edad", term)) %>% # Filtramos interacciones de edad para limpieza visual
  mutate(
    Mecanismo = case_when(
      grepl("Diario", term) & !grepl("Mujer", term) ~ "1. Efecto tratamiento (margen intensivo)",
      (grepl("No consume", term) | grepl("Ocasional", term)) & !grepl("Mujer", term) ~ "2. Sesgo de endogeneidad (causalidad reversa)",
      term == "Mujer" ~ "3. Control de heterogeneidad (sexo)",
      TRUE ~ "Otros"
    ),
    term_clean = case_when(
      grepl("Diario", term) ~ "Consumo diario (intensificación)",
      grepl("Ocasional", term) ~ "Consumo ocasional (reducción)",
      grepl("No consume", term) ~ "No consume (abstinencia)",
      term == "Mujer" ~ "Ser mujer (vs hombre)",
      TRUE ~ term
    )
  ) %>%
  filter(Mecanismo != "Otros") %>%
  filter(!grepl("Mujer", term) | term == "Mujer")

# B) Generación del Gráfico
p_forest_concept <- ggplot(df_forest_conceptual, 
                           aes(x = estimate, y = reorder(term_clean, estimate), color = Mecanismo)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.3, size = 0.8) +
  geom_point(size = 4) +
  geom_text(aes(label = paste0("OR: ", estimate)), vjust = -1.5, size = 3.5, fontface = "bold") +
  
  # Facetas con títulos centrados arriba
  facet_wrap(~Mecanismo, ncol = 1, scales = "free_y") +
  
  scale_x_log10() +
  scale_color_manual(values = c(
    "1. Efecto tratamiento (margen intensivo)" = "#D62728", 
    "2. Sesgo de endogeneidad (causalidad reversa)" = "#FF7F0E", 
    "3. Control de heterogeneidad (sexo)" = "#1F77B4" 
  )) +
  
  labs(
    title = "Identificación del efecto del consumo de azúcar",
    subtitle = "Odds Ratios usando como referencia el consumo Frecuente",
    x = "Odds Ratio", y = NULL,
    caption = "Nota: Estimación svyglm ponderada. Panel 1 muestra efecto estructural. Panel 2 muestra selección adversa."
  ) +
  theme_bw() + 
  theme(
    axis.text.y = element_text(face = "bold", size = 11),
    strip.text = element_text(face = "bold", size = 11, color = "white", hjust = 0.5), # Centrado
    strip.background = element_rect(fill = "#2c3e50"),
    legend.position = "none", 
    panel.grid.minor = element_blank(),
    panel.spacing = unit(1, "lines")
  )

print(p_forest_concept)
ggsave("Graficos-tablas/bivariado_forest_conceptual_multivariado.png", p_forest_concept, width = 11, height = 8)
```

La gráfica presenta los *Odds Ratios* estimados mediante un modelo Logit con pesos muestrales, diseñado para aislar la relación de asociación entre consumo y salud. Se utiliza el "consumo Frecuente" como grupo de control para descomponer el efecto en tres componentes:

1.  **Panel superior (efecto real del consumo sobre la salud):** Identifica la relación positiva real. Al incrementar la exposición en el margen intensivo (pasar de Frecuente a Diario), la probabilidad de enfermedad aumenta un 61% (OR: 1.61), lo que sugiere una relación estructural negativa entre el consumo intensivo de este bien y la salud medida por la aparición de enfermedades crónicas en los últimos 12 meses.

2.  **Panel medio (causalidad reversa):** captura la fuente de endogeneidad del modelo. Los coeficientes de "Abstinencia" (OR: 3.44) y "Reducción" (OR: 2.25) no reflejan causalidad, sino un **mecanismo de selección adversa (sesgo de selección en salud)**: los agentes con menor salud (enfermos) autoseleccionan niveles de consumo bajos o nulos como respuesta a su condición. Si no se separa este grupo,el estimador del efecto del azúcar estaría sesgado hacia cero o sería negativo.

3.  **Panel inferior (heterogeneidad observada):** Controlando por covariables, se puede identificar que las mujeres tienen una propensión sistemáticamente mayor al reporte de la condición, *ceteris paribus*.


## 2.4)Modelamiento de datos relacionales

```{r}
# Preparación de llaves y IDs
df_modelo <- df_bivariado %>%
  mutate(
    # Llaves Únicas
    id_hogar   = paste0(directorio, "-", secuencia_p),
    id_persona = paste0(directorio, "-", secuencia_p, "-", orden),
    
    # Asegurar formato carácter para cruces
    cod_mpio  = as.character(cod_mpio),
    cod_depto = as.character(cod_depto)
  )

# Dimensión geográfica
dim_geografia <- df_modelo %>%
  select(cod_mpio, cod_depto) %>%
  distinct() %>%
  arrange(cod_depto, cod_mpio)

# Dimensión hogar (Economía y Entorno)
# Aquí va el ingreso_pc porque es dato de hogar
dim_hogar <- df_modelo %>%
  select(id_hogar, cod_mpio, ingreso_pc) %>% 
  group_by(id_hogar) %>%
  slice(1) %>%
  ungroup()

# Dimensión del consumo de bebidas azucaradas (variable de exposición en el analisis)
dim_consumo <- df_modelo %>%
  select(
    consume_azucar,          # Si/No (Original)
    frecuencia_azucar,       # 1-6 (Original)
    freq_num,                # Numérico equivalente a si=1 y no=0
    consumo_agrupado,        # Factor ordenado (Tu variable principal)
    consumo_agrupado_txt,    # Texto
    consumo_detallado        # Factor detallado
  ) %>%
  distinct() %>%
  arrange(consumo_detallado) %>%
  mutate(id_consumo = row_number())

# Dimensión demográfica
dim_demografia <- df_modelo %>%
  select(
    id_persona,
    sexo,
    grupo_edad,        
    parentesco,
    nivel_educativo,
    # Incluimos las variables de desenlace en versión texto para filtros
    cronica_binaria,   # "Sí"/"No"
    cronica_12m        # "1"/"2"
  )

# Tabla de hechos
fact_personas <- df_modelo %>%
  # Traemos el id_consumo cruzando por TODAS las variables para ser precisos
  left_join(dim_consumo, 
            by = c("consume_azucar", "frecuencia_azucar", "freq_num", 
                   "consumo_agrupado", "consumo_agrupado_txt", "consumo_detallado")) %>%
  select(
    # Llaves para relacionar (Foreign Keys)
    id_persona,      # Relación 1:1 con Dim_Demografia
    id_hogar,        # Relación N:1 con Dim_Hogar
    id_consumo,      # Relación N:1 con Dim_Consumo
    
    # Variables Numéricas (Metrics)
    fex,             # Factor de expansión (CRUCIAL)
    edad,            # Edad exacta (para promedios)
    cronica_num,     # 0/1 (Para calcular prevalencias)
    freq_num         # Por si quieres calcular "Frecuencia promedio de consumo"
  )


# Exportando la tabla a excel para que la pueda tomar power BI
lista_tablas_final <- list(
  "Hechos_Personas" = fact_personas,
  "Dim_Hogar"       = dim_hogar,
  "Dim_Demografia"  = dim_demografia,
  "Dim_Geografia"   = dim_geografia,
  "Dim_Consumo"     = dim_consumo
)

write_xlsx(lista_tablas_final, "Data/Modelo_Datos_Completo.xlsx")
```



# Parte 3: Desarrollo de una visualización sencilla para comunicar los resultados

Revisión de Power BI

