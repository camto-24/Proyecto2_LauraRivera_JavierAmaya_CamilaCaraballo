---
title: "Proyecto 2 - Visualización y construcción de historias con datos "
subtitle: "Facultad de Economía, Universidad de los Andes"
author: "Camila Caraballo, Laura Rivera y Javier Amaya Nieto"
date: "2025-11-15"
output: html_document
---

# Setup del ambiente

```{r, include=FALSE}
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")

# Cargando los paquetes usando pacman
pacman::p_load(
  
  # A) Manipulación, limpieza y visualización de datos
  tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
  forcats,      # Herramientas para trabajar con variables categóricas (factores).
  tibble,       # Implementación moderna de data.frames.
  janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
  lubridate,    # Manejo avanzado de fechas y horas.
  skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
  stringi,      # Manipulación robusta de texto (strings).
  scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
  openxlsx,     # Guardar excel
  writexl,      # Guardar excel
  here,
  haven,
  kableExtra,
  paletteer,
  ggplot2,
  ggthemes,
  broom,
  stringr,
  gt,
  webshot2,
  Hmisc,

  # B) Modelado y análisis estadístico/econométrico
  fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
  plm,          # Modelos econométricos para datos de panel.
  AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
  lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
  sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
  survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).

  # C) Importación, exportación y generación de reportes
  haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
  readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
  stargazer,    # Creación de tablas de regresión con formato de publicación.
  knitr,         # Generación de reportes dinámicos.
  writexl
)
```

# Parte 1: Pregunta de interés

o **Pregunta de interés**: ¿Existe una asociación positiva entre el consumo de bebidas azucaradas y la probabilidad de presentar un diagnóstico de enfermedad crónica en los últimos 12 meses?

o **Definición de la población**: Son los individuos residentes de los diferentes municipios y departamentos de Colombia a los que fueron encuestados en la base de salud del Departamento Administrativo Nacional de Estadística (DANE) en el año 2023.

o **Unidad de observación**: Cada observación de la base de salud corresponde a los individuos

o **Variable dependiente**:

**Base 1: Salud**

-   Variable: Diagnóstico de enfermedad crónica (P1930)

    Pregunta: “En los últimos 12 meses, ¿a usted le han diagnosticado alguna enfermedad crónica?”

    Categorías: 1 = Sí / 2 = No

o **Variable independiente**:

-   Variable: Consumo de bebidas azucaradas (P1707)

    Pregunta: “¿Consume bebidas azucaradas?”

    Categorías: 1 = Sí / 2 = No

-   Variable: Frecuencia de consumo de bebidas azucaradas (P1707S1)

    Pregunta: “Con que frecuencia consume las bebidas azucaradas:

    Categorías: 1 Todos los días de la semana (dos o más veces al día) 2 Todos los días de la semana (una vez al día) 3 Cuatro a seis veces a la semana 4 Dos o tres veces a la semana 5 Una vez a la semana 6 Menos de una vez por semana

o **Dimensiones de análisis de interés**: Las variables control que requiere utilizar en el proyecto son:

**Base 2: Características y Composición del Hogar**

-   Variable: Sexo (P6020)

    Pregunta: “¿Cuál es el sexo de la persona?”

    Categorías: 1= Hombre / 2= Mujer

-   Variable: Edad (P6040)

    Pregunta: “¿Cuántos años cumplidos tiene?”

-   Variable: Parentesto (P6051)

    Pregunta:“¿Cuál es el parentesco de la persona con el jefe/a de hogar?”

    Categorías: 1. Jefe/a del hogar 2. Pareja, esposo/a, cónyuge, compañero/a 3. Hijo/a, hijastro/a 4. Nieto/a 5. Padre, madre, padrastro, madrastra 6. Suegro o suegra 7. Hermano/a, hemanastro/a 8. Yerno, nuera 9. Otro/a pariente del/de la jefe/a 10. Empleado/a del servicio doméstico 11. Parientes del servicio doméstico 12. Trabajador/a 13. Pensionista 14. Otro(a) no pariente

**Base 3: Educación**

-   Variable: Nivel educativo más alto alcanzado (P8587)

    Pregunta:“¿Cuál es el nivel educativo más alto que ha alcanzado?”

    Categorías: 1Ninguno 2 Preescolar 3 Básica Primaria (1º - 5º) 4 Básica secundaria (6º--9º) 5 Media (10º -13º) 6 Técnico sin título 7 Técnico con título 8 Tecnológico sin título 9 Tecnológico con título 10 Universitario sin titulo 11 Universitario con titulo 12 Postgrado sin titulo 13 Postgrado con titulo

**Base 4: Servicios del Hogar**

-   Variable: ingreso per capita del hogar (PERCAPITA)

    Descripción:Monto total de ingresos del hogar dividido entre el número de integrantes.

o **Ámbito: Geografía/periodo de referencia o Latente**: ¿Existe? Proxy propuesta (si aplica)

o **Relevancia**: La pregunta de interés de este trabajo es relevante porque permite identificar si el consumo de bebidas azucaradas está asociado con una mayor prevalencia de enfermedades crónicas, lo cual tiene implicaciones directas para la toma de decisiones en salud pública. Comprender esta relación es útil para tomar decisiones de políticas públicas enfocadas a mejorar la externalidad negativa en el consumo de estos productos por medio de impuestos, capacitaciones de salud, regulaciones a los productos con altos porcentajes de azúcar, entre otros.

Además, al contar con información territorial por departamento y municipio, es posible focalizar acciones en las zonas donde se observe mayor riesgo, optimizando recursos y fortaleciendo la planeación sanitaria. Finalmente, esta evidencia contribuye al diseño de estrategias efectivas que busquen reducir la carga de enfermedades crónicas en la población y mejorar su bienestar.

# Parte 2: EDA y modelamiento de datos

• USAR PALETA DE COLORES BLUE-TEAL DEL PAQUETE PALETEER:

-   <https://r-charts.com/es/paletas-colores/>

-   <https://coolors.co/palettes/trending>

-   <https://color.adobe.com/es/>

• USAR EL TEMA ggthemr(“fresh”) del paquete library(ggthemr) disponible para consulta en la pagina: <https://r-charts.com/es/ggplot2/temas/>

### 2.1) Preparación y comprensión inicial de los datos

#### 2.1.1) Carga de los datos y verificación de estructuras básicas

```{r}
#//////// Rutas y datos iniciales de las 4 bases
#install.packages("here")
#getwd()
ruta <- here("data")

# Base 1: Salud
salud <- read_dta(file.path(ruta, "Salud.dta"))

# Base 2: Características y composición del hogar
caracteristicas <- read_dta(file.path(ruta, "Características y composición del hogar.dta"))

# Base 3: Educación
educacion <- read_dta(file.path(ruta, "Educación.dta"))

# Base 4: Servicios del hogar
servicios <- read_dta(file.path(ruta, "Servicios del hogar.dta"))

# Base 5: Datos de la vivienda
vivienda <- read_dta(file.path(ruta, "Datos de la vivienda.dta"))

# Revisión de las bases
#str(salud)       
```

```{r}
#//////// Mantener solo las variables de interés 

# 1. Base de Salud (Nivel Persona)
df_salud <- salud %>%
  select(DIRECTORIO, SECUENCIA_P, ORDEN,
         P1707,       # Consumo bebidas azucaradas
         P1707S1,     # Frecuencia consumo
         P1930)       # Diagnóstico enfermedad crónica

# 2. Base de Características del Hogar (Nivel Persona)
df_caracteristicas <- caracteristicas %>%
  select(DIRECTORIO, SECUENCIA_P, ORDEN, FEX_C,
         P6020,       # Sexo
         P6040,       # Edad
         P6051)       # Jefe del hogar

# 3. Base de Educación (Nivel Persona)
df_educacion <- educacion %>%
  select(DIRECTORIO, SECUENCIA_P, ORDEN,
         P8587)       # Variable nivel educativo

# 4. Base de Servicios del Hogar (Nivel Hogar)
df_servicios <- servicios %>%
  select(DIRECTORIO,
         SECUENCIA_P,
         PERCAPITA   # Ingreso per cápita 
         )       

# 5. Base de Datos de la Vivienda (Nivel Vivienda)
df_vivienda <- vivienda %>%
  select(DIRECTORIO,
         P1_DEPARTAMENTO,
         P1_MUNICIPIO)

```

```{r}
#//////// Se verifican los duplicados

# 1. SALUD
n_dupli_salud <- df_salud %>% 
  group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Salud:", n_dupli_salud))

# 2. CARACTERÍSTICAS
n_dupli_caract <- df_caracteristicas %>% 
  group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Características:", n_dupli_caract))

# 3. EDUCACIÓN
n_dupli_educ <- df_educacion %>% 
  group_by(DIRECTORIO, SECUENCIA_P, ORDEN) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Educación:", n_dupli_educ))

# 4. SERVICIOS DEL HOGAR
n_dupli_servicios <- df_servicios %>%
  group_by(DIRECTORIO, SECUENCIA_P) %>%
  filter(n() > 1) %>%
  nrow()
print(paste("Duplicados en Servicios:", n_dupli_servicios))

# Corrección eliminando duplicados
df_servicios <- df_servicios %>%
  group_by(DIRECTORIO, SECUENCIA_P) %>%
  slice_head(n = 1) %>%
  ungroup()

# Verificar de nuevo
n_dupli_servicios_post <- df_servicios %>%
  group_by(DIRECTORIO, SECUENCIA_P) %>%
  filter(n() > 1) %>%
  nrow()

print(paste("Duplicados en Servicios después de corregir:", n_dupli_servicios_post))

# 5. VIVIENDA
n_dupli_vivienda <- df_vivienda %>% 
  group_by(DIRECTORIO) %>% 
  filter(n() > 1) %>% 
  nrow()
print(paste("Duplicados en Vivienda:", n_dupli_vivienda))

```

```{r}
#//////// Se unen las 5 bases
df_final_c <- df_salud %>%
  # Join 1: Nivel Persona con Persona (uno a uno)
  left_join(df_caracteristicas, by = c("DIRECTORIO", "SECUENCIA_P", "ORDEN")) %>%
  
  # Join 2: Nivel Persona con Persona (uno a uno)
  left_join(df_educacion,       by = c("DIRECTORIO", "SECUENCIA_P", "ORDEN")) %>%
  
  # Join 3: Nivel Persona con Hogar (muchos a Uno)
  left_join(df_servicios,       by = c("DIRECTORIO", "SECUENCIA_P")) %>%
  
  # Join 4: Nivel Persona con Vivienda (muchos a Uno)
  left_join(df_vivienda,        by = c("DIRECTORIO"))

# Copia del df original
df_final <- df_final_c 

# revisión general y de los missing
skimr::skim(df_final)

```

Renombrando las variables para dar mayor claridad al análisis:

```{r}
#//////// Renombramiento y limpieza final de variables
df_final <- df_final %>%
  rename(
    # --- Variable Dependiente ---
    # P1930: ¿Diagnóstico de enfermedad crónica en últimos 12 meses?
    cronica_12m = P1930,
    
    # --- Variable Independiente ---
    # P1707: ¿Consume bebidas azucaradas?
    consume_azucar = P1707,
    # P1707S1: Frecuencia de consumo
    frecuencia_azucar = P1707S1,
    
    # --- Variables de Control (Sociodemográficas) ---
    # P6020: Sexo
    sexo = P6020,
    # P6040: Edad
    edad = P6040,
    # P6051: Parentesco con jefe de hogar
    parentesco = P6051,
    # P8587: Nivel educativo más alto
    nivel_educativo = P8587,
    # Geografía
    cod_depto = P1_DEPARTAMENTO,
    cod_mpio  = P1_MUNICIPIO,
    # Economía del hogar
    ingreso_pc = PERCAPITA,
    # Factor de expansión (Peso muestral)
    fex = FEX_C
  ) %>%
  janitor::clean_names()

# Verificación de los nuevos nombres
skimr::skim(df_final)
```

#### 2.1.2) Revisión de la codificación

Se realiza una revisión de la codificación usando la documentación de la ECV para el año 2023.

***¿Sus variables numéricas son realmente numéricas?***

VARIABLES NUMERICAS: Las variables que son verdaderamente numéricas teniendo en cuenta las definiciones de la ECV-2023 son:

-   Edad

-   Ingreso per capita

```{r}
summary(df_final$edad)
summary(df_final$ingreso_pc)
summary(df_final$fex)
```

```{r}
hist(df_final$edad)
hist(log(df_final$ingreso_pc))
hist(log(df_final$fex))

class(df_final$edad)
class(df_final$ingreso_pc)
class(df_final$fex)
```

VARIABLES CATEGÓRICAS: - Directorio - Secuencia_p - orden - Sexo - Parentesco - Nivel educativo más alto alcanzado - ordinal - Diagnóstico de enfermedad crónica - Consumo de bebidas azucaradas - Frecuencia de consumo de bebidas azucaradas - ordinales - Departamento - Municipio.

```{r}
# //////// Redefinimos las variables que son categóricas por su naturaleza según la ECV
df_final <- df_final %>%
  mutate(
    
    # Se asignan como caracter para poder operar las variables
    directorio = as.character(directorio),
    secuencia_p = as.character(secuencia_p),
    orden = as.character(orden),
    cod_mpio          = as.character(cod_mpio), 
    cod_depto         = as.character(cod_depto),
    
    # se asignan como factores
    sexo              = factor(sexo),
    parentesco        = factor(parentesco),
    nivel_educativo   = factor(nivel_educativo),
    cronica_12m       = factor(cronica_12m),
    consume_azucar    = factor(consume_azucar),
    frecuencia_azucar = factor(frecuencia_azucar)

    
  )
summary(df_final)
```

**¿Las categorías están completas y correctamente etiquetadas?** **¿Hay valores como “No sabe/No responde” mezclados con categorías válidas?**


```{r}

# AJUSTE VARIABLES CATEGÓRICAS

df_final <- df_final %>%
  mutate(
    # VARIABLES DEPENDIENTE E INDEPENDIENTE
    # Variable Dependiente: Diagnóstico de enfermedad crónica (P1930)
    cronica_12m = factor(cronica_12m,
                         levels = c(1, 2),
                         labels = c("Sí", "No")),
    # Variable Independiente: Consumo de bebidas azucaradas (P1707)
    consume_azucar = factor(consume_azucar,
                            levels = c(1, 2),
                            labels = c("Sí", "No")),
    # Variable Independiente: Frecuencia de consumo de bebidas azucaradas (P1707S1)
    frecuencia_azucar = factor(frecuencia_azucar,
                               levels = 1:6,
                               labels = c("Todos los días (≥2 veces)", 
                                          "Todos los días (1 vez)", 
                                          "4 a 6 veces/semana", 
                                          "2 a 3 veces/semana", 
                                          "Una vez/semana", 
                                          "Menos de 1 vez/semana")),
    
    # VARIABLES DE CONTROL
    # sexo ya ajustada
    # Parentesco (P6051)
    parentesco = factor(parentesco,
                        levels = 1:14,
                        labels = c("Jefe/a del hogar", "Pareja/Cónyuge/Compañero/a", "Hijo/a/Hijastro/a", 
                                   "Nieto/a", "Padre/Madre/Padrastro/Madrastra", "Suegro/a", 
                                   "Hermano/a/Hermanastro/a", "Yerno/Nuera", "Otro/a pariente del/de la jefe/a", 
                                   "Empleado/a del servicio doméstico", "Parientes del servicio doméstico", 
                                   "Trabajador/a", "Pensionista", "Otro/a no pariente")),
    # Nivel educativo más alto alcanzado (P8587)
    nivel_educativo = factor(nivel_educativo,
                             levels = 1:13,
                             labels = c("Ninguno", "Preescolar", "Básica Primaria", 
                                        "Básica Secundaria", "Media", 
                                        "Técnico sin título", "Técnico con título", 
                                        "Tecnológico sin título", "Tecnológico con título", 
                                        "Universitario sin titulo", "Universitario con titulo", 
                                        "Postgrado sin titulo", "Postgrado con titulo"))
  )

skimr::skim(df_final)

```

***¿Hay valores como “No sabe/No responde” mezclados con categorías válidas?***

No existen por construcción de las preguntas y documentación de la ECV-DANE-2023



***¿Cómo se comporta el factor de expansión?***

```{r}

summary(df_final$fex)


# 1. Tabla de datos de la población total
resumen_poblacional <- df_final %>%
  summarise(
    n_muestra = n(),
    poblacion_estimada = sum(fex, na.rm = TRUE),
    peso_min = min(fex),
    peso_max = max(fex),
    cv_pesos = sd(fex) / mean(fex) * 100 # Coeficiente de Variación de los pesos
  )

print(resumen_poblacional)

# Histograma con escala logarítmica del fex
# Usamos escala logarítmica porque vimos que el rango es muy amplio (1.4 a 7353)
grafico_distribucion_fex <- ggplot(df_final, aes(x = fex)) +
  geom_histogram(bins = 100, fill = "#2C3E50", color = "white", alpha = 0.8) +
  geom_vline(aes(xintercept = mean(fex)), color = "red", linetype = "dashed", size = 1) +
  geom_vline(aes(xintercept = median(fex)), color = "blue", linetype = "dotted", size = 1) +
  scale_x_log10(labels = scales::comma) + 
  labs(
    title = "Distribución del factor de expansión (FEX)",
    subtitle = "Escala logarítmica",
    x = "Factor de expansión (personas representadas por encuestado)",
    y = "Frecuencia (número de encuestados)",
    caption = "Línea roja: media; línea azul: Mediana"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"))

# Mostrar el gráfico
print(grafico_distribucion_fex)

```

#### 2.1.3) Tratamiento de faltantes donde se registre cómo se manejan NA y categorías especiales

```{r}
skimr::skim(df_final)
```
En esta etapa de la limpieza observamos NAs en las variables del consumo de azucar, en nivel educativo y en ingreso per capita. Sin embargo revisando la documentación de la base de datos es posible que los NA de nivel educativo correspondan menores de edad que por construcción no responden la encuesta de educación. Y que los NA de las variables de consumo de azucar tengan un comportamiento también derivado de la construcción de la encuesta.  

Revisión de NAs: Se revisaron los NA en nivel_educativo, que corresponden principalmente a menores de 5 años, y se mantuvieron sin cambios junto con las variables de consume_azucar y frecuencia_azucar. 

```{r}
skimr::skim(df_final$nivel_educativo)
# Creamos un subconjunto solo con NAs en nivel educativo
df_educacion_na <- df_final %>%
  filter(is.na(nivel_educativo))
# Verificamos la edad promedio
summary(df_educacion_na$edad)
# distribución según las diferentes edades
table(df_educacion_na$edad)
```

Excluyendo de los análisis los menores de edad:

Durante la exploración de los datos, se evidenció una ausencia sistemática de información en la variable de **nivel educativo** para la población menor de 18 años (hallazgo estructural derivado del diseño de la encuesta). Dado que el objetivo del presente análisis es caracterizar la relación entre el consumo de bebidas azucaradas y las enfermedades crónicas, se decidió restringir la muestra exclusivamente a **adultos (**$\ge$ 18 años). Esta delimitación obedece a dos criterios prácticos:

1.  **Coherencia en la caracterización socioeconómica:** Para realizar cruces descriptivos válidos según el nivel educativo, es necesario contar con información completa en esta variable. Incluir menores de edad generaría una categoría de "Sin Información" artificialmente alta que dificultaría la interpretación de los perfiles poblacionales.

2.  **Focalización epidemiológica:** Las enfermedades crónicas analizadas son eventos propios de la etapa adulta. Incluir población pediátrica (donde la prevalencia del evento es cercana a cero) distorsionaría las frecuencias relativas y las tasas de prevalencia generales, opacando los patrones de salud que se buscan identificar en la población de riesgo.

```{r}
# df sin los menores de 18 años
df_final <- df_final %>%
  filter(edad >= 18) 

df_final <- df_final %>%
  mutate(
    nivel_educativo = fct_na_value_to_level(nivel_educativo, level = "Sin información"))
# Verificación final:
skim(df_final$nivel_educativo)
```
Para el caso de los NAs de la variable ingreso_pc no se encuentra una explicación y se decide imputar de forma lógica con la mediana de ingreso por municipio del. 

```{r}
df_final <- df_final %>%
  group_by(cod_mpio) %>%
  mutate(ingreso_pc = ifelse(is.na(ingreso_pc),
                             median(ingreso_pc, na.rm = TRUE),
                             ingreso_pc)) %>%
  ungroup()
skimr::skim(df_final$ingreso_pc)
```

```{r}
skimr::skim(df_final)
```

####2.1.4) Identificación de valores atípicos o valores imposibles: 

VARIABLE FEX

```{r}
# Calcular el límite estadístico (Q3 + 1.5*IQR)
Q1_fex <- quantile(df_final$fex, 0.25, na.rm = TRUE)
Q3_fex <- quantile(df_final$fex, 0.75, na.rm = TRUE)
IQR_fex <- Q3_fex - Q1_fex

limite_fex <- Q3_fex + (1.5 * IQR_fex)

limite_fex

# Graficando 
ggplot(df_final) +
  # Barras azules: Datos normales
  geom_histogram(data = filter(df_final, fex <= limite_fex),
                 aes(x = fex), fill = "steelblue", bins = 50) +
  # Barras rojas: Outliers
  geom_histogram(data = filter(df_final, fex > limite_fex),
                 aes(x = fex), fill = "red", bins = 50) +
  scale_x_log10(labels = scales::comma) + 
  labs(title = "Outliers en Factor de Expansión (FEX)", 
       subtitle = "En rojo: valores que superan el límite estadístico") +
  theme_minimal()
```
VARIABLE EDAD

```{r}
# Calcular el límite estadístico
Q1_edad <- quantile(df_final$edad, 0.25, na.rm = TRUE)
Q3_edad <- quantile(df_final$edad, 0.75, na.rm = TRUE)
IQR_edad <- Q3_edad - Q1_edad

limite_edad <- Q3_edad + (1.5 * IQR_edad)

# Ver el número exacto del corte
print(paste("Cualquier edad mayor a", round(limite_edad, 1), "es un outlier estadístico"))

# graficando
ggplot(df_final) +
  geom_histogram(data = filter(df_final, edad <= limite_edad),
                 aes(x = edad), fill = "steelblue", binwidth = 2) +
  geom_histogram(data = filter(df_final, edad > limite_edad),
                 aes(x = edad), fill = "red", binwidth = 2) +
  labs(title = "Outliers en Edad",
       subtitle = "En rojo: edades avanzadas que salen del rango intercuartílico") +
  theme_minimal()

table(df_final$edad)
```

VARIABLE INGRESO PER CAPITA

```{r}
# Calcular el límite estadístico 
Q1_ing <- quantile(df_final$ingreso_pc, 0.25, na.rm = TRUE)
Q3_ing <- quantile(df_final$ingreso_pc, 0.75, na.rm = TRUE)
IQR_ing <- Q3_ing - Q1_ing

limite_ingreso <- Q3_ing + (1.5 * IQR_ing)

# Ver el número exacto del corte
print(paste("Cualquier ingreso mayor a", round(limite_ingreso, 0), "es un outlier"))

# Graficando
ggplot(df_final) +
  geom_histogram(data = filter(df_final, ingreso_pc <= limite_ingreso),
                 aes(x = ingreso_pc), fill = "steelblue", bins = 50) +
  geom_histogram(data = filter(df_final, ingreso_pc > limite_ingreso),
                 aes(x = ingreso_pc), fill = "red", bins = 50) +
  scale_x_log10(labels = scales::dollar) + 
  labs(title = "Outliers en ingreso per cápita",
       subtitle = "En rojo: ingresos atípicamente altos") +
  theme_minimal()
```
Se realizó inicialmente una evaluación estadística de outliers buscando utilizando los cuartiles y los RIQ,para las variables de edad, ingreso_pc y fex. sin embargo, despues de una evaluación lógica de los valores mihnimos y maximos de edad e ingreso_pc se consideró que no era necesario realizar un tratamiento adicional. La variable Fex se mantiene sin modificaciones ya que es un factor de expansión. 

####2.1.5) Recodificación de variables

Codificamos dos variables de intensidad de consumo para agrupar las variables de consumo(si/no) y la variable de frecuencia de consumo (de poco frecuente a diario). Para esto decidimos crear dos variables: consumo_agrupado y consumo_detallado definidas en el codigo. 

```{r}

# copia de backup
df_final_d <- df_final

#df_final <- df_final_d

# Transformaciones de la variable X
df_analisis <- df_final %>%
  mutate(
    freq_num = case_when(
      consume_azucar == "No" ~ 0,
      TRUE ~ as.numeric(frecuencia_azucar)
    ),
    
    # Agrupada
    consumo_agrupado_txt = case_when(
      freq_num == 0 ~ "No consume",
      freq_num %in% c(5, 6) ~ "Ocasional (< 2/sem)",
      freq_num %in% c(3, 4) ~ "Frecuente (2-6/sem)",
      freq_num %in% c(1, 2) ~ "Diario (Todos los días)"
    ),
    
    # Convertimos Agrupada a Factor Ordenado
    consumo_agrupado = factor(consumo_agrupado_txt, 
                              levels = c("No consume", 
                                         "Ocasional (< 2/sem)", 
                                         "Frecuente (2-6/sem)", 
                                         "Diario (Todos los días)")),
    
    # Variable Detallada (Factor Ordenado directo)
    consumo_detallado = factor(freq_num,
                               levels = c(0, 6, 5, 4, 3, 2, 1),
                               labels = c("No consume",
                                          "< 1 vez/sem",
                                          "1 vez/sem",
                                          "2-3 veces/sem",
                                          "4-6 veces/sem",
                                          "Diario (1)",
                                          "Diario (2+)")), 
    # Creación de grupos etarios
    grupo_edad = case_when(
      edad < 30 ~ "Jóvenes (18-29)",
      edad >= 30 & edad < 40 ~ "Adultos Jóvenes (30-39)",
      edad >= 40 & edad < 50 ~ "Adultez Media (40-49)",
      edad >= 50 & edad < 60 ~ "Madurez (50-59)",
      edad >= 60 & edad < 70 ~ "Adulto mayor (60-69)",
      edad >= 70 ~ "Vejez extrema (70+)"
    ),
    # Ordenamos los niveles para los gráficops
    grupo_edad = factor(grupo_edad, levels = c("Jóvenes (18-29)", 
                                               "Adultos Jóvenes (30-39)", 
                                               "Adultez Media (40-49)", 
                                               "Madurez (50-59)", 
                                               "Adulto mayor (60-69)", 
                                               "Vejez extrema (70+)"))
  )

# Recodificando la variable sexo
df_analisis <- df_analisis %>%
  mutate(
    sexo = if_else(sexo == 1, "Hombre", "Mujer"),
    sexo = factor(sexo, levels = c("Hombre", "Mujer"))
  )

skim(df_analisis)

```

### 2.2) Análisis univariado sistemático

#### 2.2.1) Enfermedad crónica

El análisis comienza revisando cómo se distribuye la variable dependiente, es decir, si la persona reportó o no una enfermedad crónica en los últimos 12 meses. Antes de interpretar cualquier resultado, era importante verificar qué tan bien la muestra representa a la población. Para eso comparé las proporciones no ponderadas con las proporciones ponderadas usando el factor de expansión del DANE. Los valores resultaron prácticamente iguales (15.8% en la muestra vs. 15.2% en la población), así que la muestra efectivamente refleja muy bien la estructura poblacional. Por esta razón, tiene sentido utilizar las ponderaciones en el resto del análisis.

Con la estimación ponderada, la prevalencia de enfermedad crónica en los últimos 12 meses es del 15.2%, mientras que el 84.8% de la población no reporta este tipo de diagnóstico

```{r}
# Cálculo NO Ponderado (Muestra real) 
tabla_no_pond <- df_analisis %>%
  count(cronica_12m) %>%
  mutate(prop_no_pond = n / sum(n)) %>%
  rename(freq_no_pond = n)

# Cálculo Ponderado (Estimación Poblacional) 
tabla_pond <- df_analisis %>%
  group_by(cronica_12m) %>%
  summarise(freq_pond = sum(fex, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(prop_pond = freq_pond / sum(freq_pond))

# Unir Tablas 
tabla_final <- tabla_no_pond %>%
  left_join(tabla_pond, by = "cronica_12m")

print(head(tabla_final))

# Gráfico comparativo 
datos_grafico <- tabla_final %>%
  select(cronica_12m, prop_no_pond, prop_pond) %>%
  pivot_longer(
    cols = c(prop_no_pond, prop_pond),
    names_to = "tipo_medida",
    values_to = "proporcion"
  ) %>%
  mutate(
    tipo_medida = case_when(
      tipo_medida == "prop_no_pond" ~ "Muestra (No Ponderado)",
      tipo_medida == "prop_pond" ~ "Población (Ponderado)"
    )
  )

paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")

univariado_cronica <- ggplot(datos_grafico, aes(x = cronica_12m, y = proporcion, fill = tipo_medida)) +
  geom_col(position = "dodge", width = 0.7) +
  
  # Colores 
  scale_fill_manual(values = c(paleta_teal[3], paleta_teal[5])) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  
  # Etiquetas 
  labs(
    title = "Comparación: Muestra vs. Población Estimada",
    subtitle = "¿Presenta enfermedad crónica (últimos 12 meses)?",
    x = "Respuesta",
    y = "Porcentaje (%)",
    fill = "Tipo de Medida",
    caption = "Fuente: Elaboración propia"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    axis.text = element_text(color = "black", size = 11),
    panel.grid = element_blank(),
    axis.line = element_line(color = "gray") 
  ) +
  geom_text(
    aes(label = scales::percent(proporcion, accuracy = 0.1)),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 3.5
  )

print(univariado_cronica)

# Guardar 
ggsave("Graficos-tablas/univariado_cronica.png", univariado_cronica, width = 8, height = 6)
```

#### 2.2.2) Consumo agrupado

El gráfico muestra la distribución poblacional del consumo de bebidas azucaradas, comparando la muestra con los datos ponderados mediante el factor de expansión (fex). Alrededor del 36% de la población no consume estas bebidas, mientras que el consumo ocasional y frecuente representa más del 50%, y el consumo diario alcanza cerca del 12.7%. Las diferencias entre la muestra y la población son mínimas, lo que confirma que la ponderación ajusta ligeramente las proporciones para garantizar una representación confiable en el análisis de la relación con la enfermedad crónica.

```{r}

# Cálculo NO Ponderado (Muestra real)
tabla_no_pond_ca <- df_analisis %>%
  count(consumo_agrupado) %>%
  mutate(prop_no_pond = n / sum(n)) %>%
  rename(freq_no_pond = n)

# Cálculo Ponderado (Estimación poblacional)
tabla_pond_ca <- df_analisis %>%
  group_by(consumo_agrupado) %>%
  summarise(freq_pond = sum(fex, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(prop_pond = freq_pond / sum(freq_pond))

# --- Unir tablas
tabla_final_ca <- tabla_no_pond_ca %>%
  left_join(tabla_pond_ca, by = "consumo_agrupado")

print(head(tabla_final_ca))

# Gráfico
datos_grafico_ca <- tabla_final_ca %>%
  select(consumo_agrupado, prop_no_pond, prop_pond) %>%
  pivot_longer(
    cols = c(prop_no_pond, prop_pond),
    names_to = "tipo_medida",
    values_to = "proporcion"
  ) %>%
  mutate(
    tipo_medida = case_when(
      tipo_medida == "prop_no_pond" ~ "Muestra (No Ponderado)",
      tipo_medida == "prop_pond" ~ "Población (Ponderado)"
    )
  )

# Paleta TEAL
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")

univariado_consumo <- ggplot(datos_grafico_ca,
                             aes(x = consumo_agrupado,
                                 y = proporcion,
                                 fill = tipo_medida)) +
  geom_col(position = "dodge", width = 0.7) +
  
  scale_fill_manual(values = c(paleta_teal[3], paleta_teal[5])) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  
  labs(
    title = "Comparación: Muestra vs. Población Estimada",
    subtitle = "Distribución de consumo de bebidas azucaradas (agrupado)",
    x = "Categoría de consumo",
    y = "Porcentaje (%)",
    fill = "Tipo de Medida",
    caption = "Fuente: Elaboración propia"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    axis.text = element_text(color = "black", size = 11),
    panel.grid = element_blank(),
    axis.line = element_line(color = "gray")
  ) +
  
  geom_text(
    aes(label = scales::percent(proporcion, accuracy = 0.1)),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 3.5
  )

print(univariado_consumo)

# Guardar gráfico
ggsave("Graficos-tablas/univariado_consumo_agrupado.png",
       univariado_consumo,
       width = 8,
       height = 6)

```
#### 2.2.3) Consumo detallado

El gráfico muestra que el 36.8% de la población no consume bebidas azucaradas, mientras que el consumo de baja frecuencia es el más común, con 16.2% una vez por semana y 18.6% de 2 a 3 veces por semana. El consumo diario o superior alcanza alrededor del 12% de la población. Las diferencias entre la muestra y la población son mínimas, lo que refuerza la importancia de usar los datos ponderados para obtener estimaciones precisas al analizar la posible relación entre consumo de bebidas azucaradas y enfermedad crónica.

```{r}
# Cálculo NO Ponderado (Muestra real)
tabla_no_pond_cd <- df_analisis %>%
  count(consumo_detallado) %>%
  mutate(prop_no_pond = n / sum(n)) %>%
  rename(freq_no_pond = n)

# Cálculo Ponderado (Estimación poblacional)
tabla_pond_cd <- df_analisis %>%
  group_by(consumo_detallado) %>%
  summarise(freq_pond = sum(fex, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(prop_pond = freq_pond / sum(freq_pond))

# --- Unir tablas
tabla_final_cd <- tabla_no_pond_cd %>%
  left_join(tabla_pond_cd, by = "consumo_detallado")

print(head(tabla_final_cd))

# Gráfico
datos_grafico_cd <- tabla_final_cd %>%
  select(consumo_detallado, prop_no_pond, prop_pond) %>%
  pivot_longer(
    cols = c(prop_no_pond, prop_pond),
    names_to = "tipo_medida",
    values_to = "proporcion"
  ) %>%
  mutate(
    tipo_medida = case_when(
      tipo_medida == "prop_no_pond" ~ "Muestra (No Ponderado)",
      tipo_medida == "prop_pond" ~ "Población (Ponderado)"
    )
  )

# Paleta TEAL
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")

univariado_consumo_det <- ggplot(datos_grafico_cd,
                                 aes(x = consumo_detallado,
                                     y = proporcion,
                                     fill = tipo_medida)) +
  geom_col(position = "dodge", width = 0.7) +
  
  scale_fill_manual(values = c(paleta_teal[3], paleta_teal[5])) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  
  labs(
    title = "Comparación: Muestra vs. Población Estimada",
    subtitle = "Distribución de consumo de bebidas azucaradas (detallado)",
    x = "Categoría de consumo",
    y = "Porcentaje (%)",
    fill = "Tipo de Medida",
    caption = "Fuente: Elaboración propia"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    axis.text = element_text(color = "black", size = 11),
    panel.grid = element_blank(),
    axis.line = element_line(color = "gray")
  ) +
  
  geom_text(
    aes(label = scales::percent(proporcion, accuracy = 0.1)),
    position = position_dodge(width = 0.7),
    hjust = -0.1,  # Ajusta la posición horizontal de las etiquetas
    size = 3.5
  ) +
  
  coord_flip()  # Esto voltea el gráfico

print(univariado_consumo_det)

# Guardar gráfico
ggsave("Graficos-tablas/univariado_consumo_detallado.png",
       univariado_consumo_det,
       width = 8,
       height = 6)


```

#### 2.2.4) Grupo edad

El factor de expansión, refleja la distribución real de la población por edades. Esto es importante porque la edad puede influir tanto en el consumo de bebidas azucaradas como en la probabilidad de tener una enfermedad crónica. Al corregir pequeñas desviaciones en la representación de los grupos etarios, nos aseguramos de que cualquier relación que encontremos entre el consumo de bebidas azucaradas y la enfermedad crónica no esté sesgada por una muestra que sobre- o sub-representa ciertos grupos de edad. En otras palabras, la ponderación permite que el análisis sea más confiable y generalizable a la población real.

```{r}
# Cálculo NO Ponderado (Muestra real)
tabla_no_pond_ge <- df_analisis %>%
  count(grupo_edad) %>%
  mutate(prop_no_pond = n / sum(n)) %>%
  rename(freq_no_pond = n)

# Cálculo Ponderado (Estimación poblacional)
tabla_pond_ge <- df_analisis %>%
  group_by(grupo_edad) %>%
  summarise(freq_pond = sum(fex, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(prop_pond = freq_pond / sum(freq_pond))

# Unir tablas
tabla_final_ge <- tabla_no_pond_ge %>%
  left_join(tabla_pond_ge, by = "grupo_edad")

print(head(tabla_final_ge))

# Gráfico
datos_grafico_ge <- tabla_final_ge %>%
  select(grupo_edad, prop_no_pond, prop_pond) %>%
  pivot_longer(
    cols = c(prop_no_pond, prop_pond),
    names_to = "tipo_medida",
    values_to = "proporcion"
  ) %>%
  mutate(
    tipo_medida = case_when(
      tipo_medida == "prop_no_pond" ~ "Muestra (No Ponderado)",
      tipo_medida == "prop_pond" ~ "Población (Ponderado)"
    )
  )

# Paleta TEAL
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")

# Gráfico horizontal
univariado_grupo_edad <- ggplot(datos_grafico_ge,
                                  aes(x = grupo_edad,
                                      y = proporcion,
                                      fill = tipo_medida)) +
  geom_col(position = "dodge", width = 0.7) +
  
  # Colores
  scale_fill_manual(values = c(paleta_teal[3], paleta_teal[5])) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  
  # Etiquetas
  labs(
    title = "Comparación: Muestra vs. Población Estimada",
    subtitle = "Distribución por grupos de edad",
    x = "Grupo de edad",
    y = "Porcentaje (%)",
    fill = "Tipo de Medida",
    caption = "Fuente: Elaboración propia"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    axis.text = element_text(color = "black", size = 11),
    panel.grid = element_blank(),
    axis.line = element_line(color = "gray")
  ) +
  
  geom_text(
    aes(label = scales::percent(proporcion, accuracy = 0.1)),
    position = position_dodge(width = 0.7),
    hjust = -0.1,   
    size = 3.5
  ) +
  coord_flip()

print(univariado_grupo_edad)

# Guardar gráfico
ggsave("Graficos-tablas/univariado_grupo_edad.png",
       univariado_grupo_edad,
       width = 8,
       height = 6)


```
#### 2.2.5) Edad

El gráfico de densidad muestra que la distribución de edad de la muestra y de la población ponderada es muy similar, aunque la muestra tiende a sobre-representar ligeramente a los jóvenes de 25 a 35 años, mientras que la población ponderada muestra mayor densidad en edades intermedias y mayores (45-70 años). Esta pequeña diferencia destaca la importancia de la ponderación para corregir sesgos y asegurar estimaciones precisas de la edad en el estudio.

```{r}
# Estadísticos No Ponderados
stats_no_pond <- df_analisis %>%
  summarise(
    N_obs = n(),
    Media = mean(edad, na.rm = TRUE),
    DS = sd(edad, na.rm = TRUE),
    Q25 = quantile(edad, 0.25, na.rm = TRUE),
    Mediana = quantile(edad, 0.50, na.rm = TRUE),
    Q75 = quantile(edad, 0.75, na.rm = TRUE),
    RIQ = Q75 - Q25,
    Min = min(edad, na.rm = TRUE),
    Max = max(edad, na.rm = TRUE)
  ) %>%
  mutate(Tipo = "No ponderado")

# Estadísticos Ponderados
stats_pond <- df_analisis %>%
  summarise(
    N_obs = sum(fex, na.rm = TRUE),
    Media = weighted.mean(edad, w = fex, na.rm = TRUE),
    DS = sqrt(sum(fex * (edad - weighted.mean(edad, w = fex, na.rm = TRUE))^2, na.rm = TRUE) / sum(fex, na.rm = TRUE)),
    Q25 = wtd.quantile(edad, weights = fex, probs = 0.25, na.rm = TRUE),
    Mediana = wtd.quantile(edad, weights = fex, probs = 0.5, na.rm = TRUE),
    Q75 = wtd.quantile(edad, weights = fex, probs = 0.75, na.rm = TRUE),
    RIQ = Q75 - Q25,
    Min = min(edad, na.rm = TRUE),
    Max = max(edad, na.rm = TRUE)
  ) %>%
  mutate(Tipo = "Ponderado")

# Combinar tablas 
tabla_final_edad <- bind_rows(stats_no_pond, stats_pond) %>%
  select(Tipo, N_obs, Media, DS, Mediana, RIQ, Min, Max) %>%
  mutate(across(c(Media, DS, Mediana, RIQ, Min, Max), ~round(., 2)))

print(tabla_final_edad)

# Gráfico de densidad comparativo
paleta_teal <- c("#0097A7", "#26C6DA") 

grafico_densidad_edad <- ggplot() +
  geom_density(data = df_analisis,
               aes(x = edad, color = "No ponderado", fill = "No ponderado"),
               alpha = 0.5, linewidth = 1) +
  geom_density(data = df_analisis,
               aes(x = edad, weight = fex, color = "Ponderado", fill = "Ponderado"),
               alpha = 0.5, linewidth = 1) +
  scale_fill_manual(values = c("No ponderado" = paleta_teal[2], "Ponderado" = paleta_teal[1])) +
  scale_color_manual(values = c("No ponderado" = paleta_teal[1], "Ponderado" = paleta_teal[1])) +
  labs(
    title = "Distribución de la Edad: No Ponderada vs Ponderada",
    x = "Edad",
    y = "Densidad",
    fill = "Tipo de Medida",
    color = "Tipo de Medida",
    caption = "Fuente: Elaboración propia"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    legend.position = "bottom",
    axis.text = element_text(color = "black")
  )

print(grafico_densidad_edad)

# Guardar gráfico 
ggsave("Graficos-tablas/univariado_edad.png",
       grafico_densidad_edad,
       width = 8,
       height = 6)


```
### 2.3) Análisis bivariado guiado por la pregunta

Una vez comprendidas las variables, realice comparaciones que respondan directamente a la pregunta de indagación. El objetivo es producir evidencia gráfica relevante para sustentar una respuesta. Puede tomar como referencia las sugerencias de visualización del enunciado de la Actividad 2, según corresponda. Incluya los gráficos que considere pertinentes y que ilustren la relaciones entre variables de la pregunta de indagación en el informe. Acompáñelos de un análisis interpretativo.

#### 2.3.1) Preparación de variables - bivariado

Ajustando el dataset df_bivariado, corrigiendo los NAs de educación, ordenando los factores de consumo (para que el gráfico tenga sentido de menor a mayor) y creando una variable de edad categórica.

```{r}
df_bivariado <- df_analisis %>%
  mutate(
    # Manejo de NAs en Educación: 
    nivel_educativo = fct_na_value_to_level(nivel_educativo, level = "Sin Información"),
    
    # Ordenamiento lógico de la variable de exposición para gráficas
    consumo_agrupado = fct_relevel(consumo_agrupado, 
                                   "No consume", 
                                   "Ocasional (< 2/sem)", 
                                   "Frecuente (2-6/sem)", 
                                   "Diario (Todos los días)"),
  )

```

#### 2.3.2) Tablas de prevalencias

Generando las tablas resumen numéricas que alimentarán los gráficos.

```{r}
# A) Tabla global
df_grafico_global <- df_bivariado %>%
  group_by(consumo_agrupado) %>%
  summarise(
    poblacion_total = sum(fex, na.rm = TRUE),
    poblacion_enferma = sum(fex[cronica_12m == "Sí"], na.rm = TRUE),
    prevalencia = poblacion_enferma / poblacion_total,
    preva_100 = (poblacion_enferma / poblacion_total) * 100,
    pob_total_mill = round(poblacion_total / 1000000, 2),
    .groups = "drop"
  )

# B) Tabla estratificada por edad
df_grafico_estratificado <- df_bivariado %>%
  group_by(grupo_edad, consumo_agrupado) %>%
  summarise(
    poblacion_total = sum(fex, na.rm = TRUE),
    poblacion_enferma = sum(fex[cronica_12m == "Sí"], na.rm = TRUE),
    prevalencia = poblacion_enferma / poblacion_total,
    preva_100 = (poblacion_enferma / poblacion_total) * 100,
    .groups = "drop"
  )

# C) Tabla estratificada por sexo y edad (para heatmap y líneas)
df_grafico_sexo <- df_bivariado %>%
  group_by(sexo, grupo_edad, consumo_agrupado) %>%
  summarise(
    poblacion_total = sum(fex, na.rm = TRUE),
    poblacion_enferma = sum(fex[cronica_12m == "Sí"], na.rm = TRUE),
    prevalencia = poblacion_enferma / poblacion_total,
    preva_100 = (poblacion_enferma / poblacion_total) * 100,
    .groups = "drop"
  ) %>%
  mutate(grupo_edad_rev = fct_rev(grupo_edad)) 

```

Ahora exportamos las tablas al formato seleccionado:

```{r}
# Función auxiliar para formatear y guardar
exportar_html <- function(data, titulo, nombre_archivo) {
  data %>%
    mutate(across(where(is.numeric), \(x) round(x, 2))) %>% 
    kbl(caption = titulo, format = "html", align = 'c') %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                  full_width = F, position = "center") %>%
    row_spec(0, bold = T, color = "white", background = "#2c3e50") %>% 
    save_kable(file = file.path("Graficos-tablas", paste0(nombre_archivo, ".html")))
}

# Generar las 3 tablas clave
exportar_html(df_grafico_global, "Prevalencia Global Ponderada", "Bivariado_prevalencia_global")
exportar_html(df_grafico_estratificado, "Prevalencia por Edad", "Bivariado_prevalencia_edad")
exportar_html(df_grafico_sexo, "Prevalencia por Sexo y Edad", "Bivariado_prevalencia_edad_sexo")
```

#### 2.3.3) Visualizaciones del bivariado

```{r}
# ==============================================================================
# Visualización bivariada 

library(ggplot2)
library(ggthemes)
library(scales)
library(paletteer)

# Definiendo la paleta
paleta_teal <- c("#E0F7FA", "#80DEEA", "#26C6DA", "#0097A7", "#006064")

# --- GRÁFICO 1: GLOBAL (PARADOJA) ---
p_global <- ggplot(df_grafico_global, aes(x = consumo_agrupado, y = prevalencia)) +
  geom_line(group = 1, linetype = "dashed", color = "grey50") +
  geom_point(size = 5, color = "#4E79A7") + 
  geom_text(aes(label = paste0(round(preva_100, 1), "%")), 
            vjust = -1.5, size = 4, fontface = "bold", color = "#2c3e50") +
  scale_y_continuous(labels = percent_format(), limits = c(0, 0.30)) + 
  labs(
    title = "Prevalencia de enf. crónica según intensidad de consumo",
    subtitle = "Análisis global: paradoja de causalidad reversa",
    x = NULL, y = "Prevalencia (%)",
    caption = "Fuente: ECV 2023. Población expandida."
  ) +
  theme_few() + 
  theme(axis.text.x = element_text(angle = 15, hjust = 1))

# --- GRÁFICO 2: ESTRATIFICADO POR EDAD (CURVA J) ---
p_estratificado <- ggplot(df_grafico_estratificado,
                          aes(x = consumo_agrupado, y = prevalencia, color = grupo_edad)) +
  geom_line(aes(group = grupo_edad), linewidth = 1, alpha = 0.8) + 
  geom_point(size = 3) + 
  facet_wrap(~grupo_edad, scales = "free_y") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
  scale_color_paletteer_d("ggthemes::Tableau_10") +
  labs(
    title = "Prevalencia según intensidad de consumo por grupo etario",
    subtitle = "Controlando por edad aparecen patrones de riesgo (Curva J)",
    x = "Frecuencia de consumo", 
    y = "Prevalencia (%)", 
    color = "Grupo de edad"
  ) +
  ggthemes::theme_few() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), 
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 10) 
  )

# --- GRÁFICO 3: MAPA DE CALOR SEXO ---
df_heatmap_sexo <- df_grafico_sexo %>% mutate(grupo_edad = fct_rev(grupo_edad))

p_heatmap_sexo <- ggplot(df_heatmap_sexo, aes(x = consumo_agrupado, y = grupo_edad, fill = prevalencia)) +
  geom_tile(color = "white", linewidth = 0.5) +
  facet_wrap(~sexo) + 
  geom_text(aes(label = paste0(round(preva_100, 1), "%")), 
            color = ifelse(df_heatmap_sexo$preva_100 > 25, "white", "#2c3e50"), 
            size = 3, fontface = "bold") +
  scale_fill_gradientn(colors = paleta_teal, labels = percent_format()) +
  labs(
    title = "Mapa de calor: riesgo de enfermedad crónica por Sexo",
    subtitle = "Efecto del sesgo de supervivencia",
    x = NULL, y = NULL, fill = "Prevalencia"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10, face = "bold"),
    strip.text = element_text(size = 12, face = "bold", color = "#006064"),
    panel.grid = element_blank()
  )

# --- GRÁFICO 4: TENDENCIAS POR SEXO ---
p_lineas_sexo <- ggplot(df_grafico_sexo, 
                        aes(x = consumo_agrupado, y = prevalencia, color = sexo, group = sexo)) +
  geom_line(size = 1.2, alpha = 0.9) +
  geom_point(size = 3) +
  
  # Haciendo el faceting por grupo de edad
  facet_wrap(~grupo_edad, nrow = 1) + 
  
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  
  # Paleta seleccionada para el proyecto
  scale_color_manual(values = c("Hombre" = "#2c3e50", "Mujer" = "#26C6DA")) +
  
  labs(
    title = "Tendencias por sexo y grupo etario",
    subtitle = "Comparación de prevalencia entre hombres y mujeres",
    x = NULL,
    y = "Prevalencia (%)",
    color = "Sexo"
  ) +
  theme_few() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    legend.position = "bottom",
    strip.text = element_text(face = "bold")
  )

# Guardar gráficos
ggsave("Graficos-tablas/bivariado_graph_global.png", p_global, width = 8, height = 6)
ggsave("Graficos-tablas/bivariado_graph_edad.png", p_estratificado, width = 10, height = 6)
ggsave("Graficos-tablas/bivariado_heatmap_graph_edad_sexo.png", p_heatmap_sexo, width = 12, height = 7)
ggsave("Graficos-tablas/bivaariado_lineas_sexo_edad.png", p_lineas_sexo, width = 12, height = 6)

# Mostrar en RMarkdown
print(p_global)
print(p_estratificado)
print(p_heatmap_sexo)
print(p_lineas_sexo)
```

Análisis global (paradoja de la causalidad reversa): al examinar la relación cruda entre el consumo de bebidas azucaradas y la enfermedad crónica a nivel nacional, se observa una asociación negativa aparente: la prevalencia de enfermedad es drásticamente mayor en el grupo que "No consume" (24.0%) comparado con quienes consumen "Diariamente" (8.6%). Desde una perspectiva epidemiológica y económica, este hallazgo no sugiere un efecto protector del azúcar, sino que evidencia un fuerte sesgo de selección por causalidad inversa (fenómeno sick-quitter). Es altamente probable que el diagnóstico de patologías como diabetes o hipertensión actúe como el determinante exógeno que fuerza a los individuos a modificar su dieta, concentrando así a la población con peor salud en la categoría de "No consumidores" y distorsionando la estimación del riesgo real.

Estratificación por grupo etario (heterogeneidad del efecto): Al controlar por decenios de edad, se despeja parcialmente esta distorsión. Si bien el efecto sick-quitter persiste transversalmente (los "No consumidores" siempre son los más enfermos en todos los grupos etarios), el comportamiento dentro de la población consumidora revela patrones divergentes. En los grupos económicamente activos (18 a 59 años), emerge una tendencia no lineal en forma de "J": tras excluir a los abstemios, se observa un gradiente positivo donde la prevalencia repunta al transitar de un consumo "Frecuente" a uno "Diario", sugiriendo una asociación dosis-respuesta oculta en el análisis global. Por el contrario, en la vejez (60+ años), la tendencia se torna linealmente negativa, comportamiento atribuible a la restricción médica estricta y a un marcado sesgo de supervivencia, donde los individuos más vulnerables fallecen prematuramente, disminuyendo artificialmente la prevalencia observada en los consumidores longevos.

Dinámica de género y sesgo de supervivencia diferencial: El análisis de las trayectorias vitales añade una capa de complejidad mediante la brecha de género. Aunque en etapas tempranas (18-29 años) las curvas de prevalencia se solapan, con la edad se produce una separación progresiva donde las mujeres reportan tasas sistemáticamente más altas, atribuible a una mayor frecuencia de diagnóstico y uso de servicios de salud frente al sub-registro masculino. Críticamente, al llegar a la tercera edad, se evidencia una atrición diferencial: mientras las mujeres mantienen el patrón de riesgo en "J" hasta la vejez extrema, los hombres pierden dicha señal a partir de los 60 años. Esto sugiere que los hombres con alto consumo y predisposición a enfermar sufren una mortalidad prematura selectiva, dejando en la muestra de ancianos a un subgrupo de "sobrevivientes resilientes" que sesgan la asociación hacia la nulidad, fenómeno menos acentuado en mujeres debido a su mayor esperanza de vida con morbilidad.

Conclusión del análisis descriptivo: en síntesis, la evidencia descriptiva bivariada sugiere que sí existe una asociación positiva estructural entre la intensidad del consumo y la enfermedad crónica, pero esta relación es condicional a la edad y al sexo. De esta manera, el análisis bivariado puede ser insuficiente debido a la contaminación por causalidad reversa y sesgos de selección y supervivencia. Por consiguiente, es importasnte usar modelos multivariados que aíslen el riesgo biológico real, controlando por la confusión demográfica y ajustando la categoría de referencia para mitigar el sesgo de endogeneidad introducido por el cambio de comportamiento post-diagnóstico.

#### 2.3.4) Prueba estadística bivariada

Usamos el paquete survey para poder montar la prueba de hipótesis usando el factor de expansión de la ECV.

```{r}
# --- CHUNK 5: Test de Independencia con Diseño Muestral ---
library(survey)

# Definiendo el diseño muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_bivariado)

# Tabla cruzada ponderada 
print("--- Tabla de Contingencia Poblacional (Millones de personas) ---")
svytable(~consumo_agrupado + cronica_12m, design = diseno_muestral)

# Test de Chi-Cuadrado de Rao-Scott (Corrección para encuestas complejas)
test_survey <- svychisq(~consumo_agrupado + cronica_12m, design = diseno_muestral)

print("--- Resultado Chi-Cuadrado Ajustado (Rao-Scott) ---")
print(test_survey)
```

#### 2.3.5) Multivariado

```{r}
library(survey)
library(broom)

# Recodificando 
df_bivariado <- df_bivariado %>%
  mutate(
    cronica_num = case_when(
      cronica_12m %in% c("Sí") ~ 1,
      cronica_12m %in% c("No") ~ 0,
      is.na(cronica_12m) ~ NA_real_,
      TRUE ~ NA_real_ 
    )
  )

# Configuración de Referencias:
# Referencia: Frecuente (Control) | Jóvenes | Hombres
df_model <- df_bivariado %>%
  mutate(
    consumo_agrupado = relevel(consumo_agrupado, ref = "Frecuente (2-6/sem)"),
    grupo_edad = relevel(grupo_edad, ref = "Jóvenes (18-29)"),
    sexo = relevel(sexo, ref = "Hombre")
  )

# Diseño muestral
diseno_muestral <- svydesign(ids = ~1, weights = ~fex, data = df_model)

# Ajuste del Modelo (Interacción triple)
modelo_interaccion <- svyglm(
  cronica_num ~ consumo_agrupado * grupo_edad * sexo, 
  design = diseno_muestral,
  family = quasibinomial()
)

# Tabla de resultados tidy
tabla_resultados <- tidy(modelo_interaccion, exponentiate = TRUE, conf.int = TRUE) %>%
  select(term, estimate, conf.low, conf.high, p.value) %>%
  mutate(
    across(c(estimate, conf.low, conf.high), \(x) round(x, 2)),
    p_valor_formato = ifelse(p.value < 0.001, "< 0.001", as.character(round(p.value, 3)))
  ) %>%
  # Limpieza de nombres de variables
  mutate(term = gsub("consumo_agrupado", "Consumo: ", term),
         term = gsub("grupo_edad", "Edad: ", term),
         term = gsub("sexoMujer", "Mujer", term),
         term = gsub(":", " x ", term))
```

Al establecer el 'Consumo Frecuente' como categoría basal —un grupo teóricamente expuesto pero sin el comportamiento extremo de restricción médica—, el modelo multivariado desveló dos mecanismos opuestos que operan simultáneamente en la población. Por un lado, se aisló el Efecto Biológico: la intensificación del hábito hacia un consumo 'Diario' incrementa significativamente la probabilidad de enfermedad crónica (OR = 1.61), confirmando la hipótesis de riesgo por exceso de exposición. Por otro lado, se dimensionó la magnitud de la Causalidad Inversa (Efecto Sick-Quitter): paradójicamente, la reducción del consumo a niveles 'Ocasionales' (OR = 2.25) o la abstinencia total (OR = 3.44) se asocian con los mayores niveles de riesgo. Este gradiente inverso no indica que dejar el azúcar enferme, sino que la enfermedad fuerza a los pacientes a migrar hacia categorías de bajo consumo, concentrando artificialmente la patología en los grupos de menor exposición aparente. El modelo confirma así que la relación no es lineal, sino en forma de 'J', donde tanto el exceso (por causa) como la carencia (por consecuencia) marcan los puntos altos de prevalencia.

#### 2.3.6) Forest plot de la regresión

```{r}
# Preparación de datos para el Forest Plot
# Clasificamos los coeficientes según el mecanismo económico/epidemiológico
df_forest_conceptual <- tabla_resultados %>%
  filter(term == "Mujer" | grepl("Consumo", term)) %>%
  filter(!grepl("Edad", term)) %>% 
  mutate(
    Mecanismo = case_when(
      grepl("Diario", term) & !grepl("Mujer", term) ~ "1. Efecto tratamiento (margen intensivo)",
      (grepl("No consume", term) | grepl("Ocasional", term)) & !grepl("Mujer", term) ~ "2. Sesgo de endogeneidad (causalidad reversa)",
      term == "Mujer" ~ "3. Control de heterogeneidad (sexo)",
      TRUE ~ "Otros"
    ),
    term_clean = case_when(
      grepl("Diario", term) ~ "Consumo diario (intensificación)",
      grepl("Ocasional", term) ~ "Consumo ocasional (reducción)",
      grepl("No consume", term) ~ "No consume (abstinencia)",
      term == "Mujer" ~ "Ser mujer (vs hombre)",
      TRUE ~ term
    )
  ) %>%
  filter(Mecanismo != "Otros") %>%
  filter(!grepl("Mujer", term) | term == "Mujer")

# B) Generación del Gráfico
p_forest_concept <- ggplot(df_forest_conceptual, 
                           aes(x = estimate, y = reorder(term_clean, estimate), color = Mecanismo)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.3, size = 0.8) +
  geom_point(size = 4) +
  geom_text(aes(label = paste0("OR: ", estimate)), vjust = -1.5, size = 3.5, fontface = "bold") +
  
  # Facetas con títulos centrados arriba
  facet_wrap(~Mecanismo, ncol = 1, scales = "free_y") +
  
  scale_x_log10() +
  scale_color_manual(values = c(
    "1. Efecto tratamiento (margen intensivo)" = "#D62728", 
    "2. Sesgo de endogeneidad (causalidad reversa)" = "#FF7F0E", 
    "3. Control de heterogeneidad (sexo)" = "#1F77B4" 
  )) +
  
  labs(
    title = "Identificación del efecto del consumo de azúcar",
    subtitle = "Odds Ratios usando como referencia el consumo Frecuente",
    x = "Odds Ratio", y = NULL,
    caption = "Nota: Estimación svyglm ponderada. Panel 1 muestra efecto estructural. Panel 2 muestra selección adversa."
  ) +
  theme_bw() + 
  theme(
    axis.text.y = element_text(face = "bold", size = 11),
    strip.text = element_text(face = "bold", size = 11, color = "white", hjust = 0.5), # Centrado
    strip.background = element_rect(fill = "#2c3e50"),
    legend.position = "none", 
    panel.grid.minor = element_blank(),
    panel.spacing = unit(1, "lines")
  )

print(p_forest_concept)
ggsave("Graficos-tablas/bivariado_forest_conceptual_multivariado.png", p_forest_concept, width = 11, height = 8)
```

La gráfica presenta los *Odds Ratios* estimados mediante un modelo Logit con pesos muestrales, diseñado para aislar la relación de asociación entre consumo y salud. Se utiliza el "consumo Frecuente" como grupo de control para descomponer el efecto en tres componentes:

1.  **Panel superior (efecto real del consumo sobre la salud):** Identifica la relación positiva real. Al incrementar la exposición en el margen intensivo (pasar de Frecuente a Diario), la probabilidad de enfermedad aumenta un 61% (OR: 1.61), lo que sugiere una relación estructural negativa entre el consumo intensivo de este bien y la salud medida por la aparición de enfermedades crónicas en los últimos 12 meses.

2.  **Panel medio (causalidad reversa):** captura la fuente de endogeneidad del modelo. Los coeficientes de "Abstinencia" (OR: 3.44) y "Reducción" (OR: 2.25) no reflejan causalidad, sino un **mecanismo de selección adversa (sesgo de selección en salud)**: los agentes con menor salud (enfermos) autoseleccionan niveles de consumo bajos o nulos como respuesta a su condición. Si no se separa este grupo,el estimador del efecto del azúcar estaría sesgado hacia cero o sería negativo.

3.  **Panel inferior (heterogeneidad observada):** Controlando por covariables, se puede identificar que las mujeres tienen una propensión sistemáticamente mayor al reporte de la condición, *ceteris paribus*.

## 2.4) Modelamiento de datos relacionales

```{r}
# Preparación de llaves y IDs
df_modelo <- df_bivariado %>%
  mutate(
    # Llaves Únicas
    id_hogar   = paste0(directorio, "-", secuencia_p),
    id_persona = paste0(directorio, "-", secuencia_p, "-", orden),
    
    # Asegurar formato carácter para cruces
    cod_mpio  = as.character(cod_mpio),
    cod_depto = as.character(cod_depto),
    id_geografia = paste0(cod_depto, cod_mpio),
  )

# Dimensión geográfica
dim_geografia <- df_modelo %>%
  select(id_geografia, cod_depto, cod_mpio) %>%
  distinct() %>% 
  group_by(id_geografia) %>%
  slice(1) %>%
  ungroup()

# Dimensión hogar (Economía y Entorno)
# Aquí va el ingreso_pc porque es dato de hogar
dim_hogar <- df_modelo %>%
  select(id_hogar, id_geografia, ingreso_pc) %>% 
  group_by(id_hogar) %>%
  slice(1) %>%
  ungroup()

# Dimensión del consumo de bebidas azucaradas (variable de exposición en el analisis)
dim_consumo <- df_modelo %>%
  select(
    consume_azucar,          # Si/No (Original)
    frecuencia_azucar,       # 1-6 (Original)
    freq_num,                # Numérico equivalente a si=1 y no=0
    consumo_agrupado,        # Factor ordenado (Tu variable principal)
    consumo_agrupado_txt,    # Texto
    consumo_detallado        # Factor detallado
  ) %>%
  distinct() %>%
  arrange(consumo_detallado) %>%
  mutate(id_consumo = row_number())

# Dimensión demográfica
dim_demografia <- df_modelo %>%
  select(
    id_persona,
    sexo,
    grupo_edad,        
    parentesco,
    nivel_educativo,
    # Incluimos las variables de desenlace en versión texto para filtros
    cronica_12m        # "1"/"2"
  )

# Tabla de hechos
fact_personas <- df_modelo %>%
  # Traemos el id_consumo cruzando por TODAS las variables para ser precisos
  left_join(dim_consumo, 
            by = c("consume_azucar", "frecuencia_azucar", "freq_num", 
                   "consumo_agrupado", "consumo_agrupado_txt", "consumo_detallado")) %>%
  select(
    # Llaves para relacionar (Foreign Keys)
    id_persona,      # Relación 1:1 con Dim_Demografia
    id_hogar,        # Relación N:1 con Dim_Hogar
    id_consumo,      # Relación N:1 con Dim_Consumo
    
    # Variables Numéricas (Metrics)
    fex,             # Factor de expansión 
    edad,            # Edad exacta (para promedios)
    cronica_num,     # 0/1 (Para calcular prevalencias)
    freq_num         # Por si quieres calcular "Frecuencia promedio de consumo"
  )


# Exportando la tabla a excel para que la pueda tomar power BI
lista_tablas_final <- list(
  "Hechos_Personas" = fact_personas,
  "Dim_Hogar"       = dim_hogar,
  "Dim_Demografia"  = dim_demografia,
  "Dim_Geografia"   = dim_geografia,
  "Dim_Consumo"     = dim_consumo
)

write_xlsx(lista_tablas_final, "Data/Modelo_Datos_Completo.xlsx")
```

# Parte 3: Desarrollo de una visualización sencilla para comunicar los resultados

Revisión de Power BI
